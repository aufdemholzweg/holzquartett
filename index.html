<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Holz-Quartett</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcode/1.5.3/qrcode.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        body { font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; font-weight: 300; }
        .card-3d { transform-style: preserve-3d; transition: transform 0.6s; }
        .card-flipped { transform: rotateY(180deg); }
        .card-front, .card-back { backface-visibility: hidden; position: absolute; width: 100%; height: 100%; }
        .card-back {
            transform: rotateY(180deg);
            background-image: url('https://raw.githubusercontent.com/aufdemholzweg/holzquartett/65fd843a4db1ee434faaf81a32f77951a5afb72a/images/background_card.jpg');
            background-size: cover; background-position: center;
        }
        .wood-texture { background: linear-gradient(45deg, #8B4513 25%, transparent 25%),
                            linear-gradient(-45deg, #8B4513 25%, transparent 25%),
                            linear-gradient(45deg, transparent 75%, #8B4513 75%),
                            linear-gradient(-45deg, transparent 75%, #8B4513 75%);
                        background-size: 20px 20px; background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
                        background-color: #D2B48C; opacity: 0.1; }
        .animate-pop-in { animation: pop-in 0.5s ease-out forwards; }
        .animate-glow-win { animation: glow-win 1.2s ease-out; }
        .animate-glow-lose { animation: glow-lose 1.2s ease-out; }
        @keyframes pop-in { 0% { transform: scale(0); opacity: 0; } 70% { transform: scale(1.2); opacity: 1; } 100% { transform: scale(1); } }
        @keyframes glow-win { 0% { box-shadow: 0 0 0 0 rgba(74, 222, 128, 0); } 50% { box-shadow: 0 0 30px 15px rgba(74, 222, 128, 0.6); } 100% { box-shadow: 0 0 0 0 rgba(74, 222, 128, 0); } }
        @keyframes glow-lose { 0% { box-shadow: 0 0 0 0 rgba(248, 113, 113, 0); } 50% { box-shadow: 0 0 30px 15px rgba(248, 113, 113, 0.6); } 100% { box-shadow: 0 0 0 0 rgba(248, 113, 113, 0); } }
        .hover-lift:hover { transform: translateY(-4px); box-shadow: 0 10px 25px rgba(0,0,0,0.15); }
        .status-flash-win { animation: flash-green 1.2s ease-out; }
        .status-flash-lose { animation: flash-red 1.2s ease-out; }
        @keyframes flash-green { 50% { background-color: #22c55e; box-shadow: 0 0 15px #22c55e; } }
        @keyframes flash-red { 50% { background-color: #ef4444; box-shadow: 0 0 15px #ef4444; } }
        .falling-star { position: absolute; font-size: 7rem; z-index: 100; animation: fall-and-fade 1.2s ease-in forwards; }
        @keyframes fall-and-fade { 0% { transform: translateY(-30px) scale(1.5); opacity: 0; }
                                  30% { transform: translateY(0) scale(1); opacity: 1; }
                                  100% { transform: translateY(var(--end-y)) scale(0.3); opacity: 0; } }
        .card-background {
            background-image: url('https://raw.githubusercontent.com/aufdemholzweg/holzquartett/e7cfc18394e2e7f2d0b91df1138b0d7bc7930699/images/background_front.jpg');
            background-size: cover; background-position: center;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-amber-50 to-orange-100 min-h-screen">

    <div id="splashScreen" class="fixed inset-0 z-[100] flex items-start justify-center transition-opacity duration-700 ease-out bg-white">
        <div class="absolute inset-0 bg-cover bg-center" style="background-image: url('https://raw.githubusercontent.com/aufdemholzweg/holzquartett/65fd843a4db1ee434faaf81a32f77951a5afb72a/images/background_card.jpg');"></div>
        <div class="absolute inset-0 bg-black bg-opacity-30"></div>
        <div class="relative text-center animate-pop-in mt-32" style="animation-duration: 1.2s;">
            <h1 class="text-4xl sm:text-5xl font-bold text-white" style="text-shadow: 2px 2px 10px rgba(0,0,0,0.6);">üå≥ HOLZEN! üå≥</h1>
            <p class="text-xl text-amber-100 mt-2" style="text-shadow: 1px 1px 6px rgba(0,0,0,0.5);">Holz ist Trumpf</p>
        </div>
    </div>

    <header class="bg-white shadow-sm border-b-2 border-amber-200">
        <div class="max-w-6xl mx-auto px-4 p-3 relative">
            <button onclick="window.resetGame()" class="absolute top-3 left-4 text-3xl text-gray-400 hover:text-amber-600 transition-colors z-20" title="Spiel neustarten">‚ò∞</button>
            <h1 class="text-2xl font-bold text-amber-800 text-center">üå≥ HOLZEN! üå≥</h1>
            <p class="text-xs text-gray-500 text-center mt-1">C.Lehr, in Verbindung mit meiner Abschlussarbeit</p>
        </div>
    </header>

    <div id="setupModal" class="hidden fixed inset-0 bg-black bg-opacity-50 items-center justify-center z-50">
        <div class="bg-white rounded-xl p-8 max-w-md w-full mx-4 shadow-2xl text-center">
            <h2 class="text-2xl font-bold text-amber-800 mb-6">Spielmodus w√§hlen</h2>
            <div class="space-y-4">
                <button onclick="window.showNamePrompt('ai')" class="w-full bg-amber-600 hover:bg-amber-700 text-white font-semibold py-4 px-6 rounded-lg transition-colors text-lg">üéÆ gegen Computer</button>
                <button onclick="window.showNamePrompt('multiplayer')" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-4 px-6 rounded-lg transition-colors text-lg">üßë‚Äçü§ù‚Äçüßë online gegen Freunde</button>
            </div>
            <div class="mt-6 flex items-center justify-center space-x-2">
                <span class="text-gray-700">üîá </span>
                <label for="soundToggle" class="relative inline-flex items-center cursor-pointer">
                    <input type="checkbox" id="soundToggle" class="sr-only peer">
                    <div class="w-11 h-6 bg-gray-200 rounded-full peer peer-focus:ring-2 peer-focus:ring-amber-300 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-amber-600"></div>
                </label>
                <span class="text-gray-700"> üîä</span>
            </div>
        </div>
    </div>

    <div id="nameModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div class="bg-white rounded-xl p-8 max-w-md w-full mx-4 shadow-2xl">
            <h2 class="text-2xl font-bold text-amber-800 mb-6 text-center">Dein Name</h2>
            <div class="space-y-3">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Bitte gib deinen Namen ein:</label>
                    <input type="text" id="playerName" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-amber-500 focus:border-transparent" placeholder="Spielername">
                </div>
                <button id="nameSubmitButton" class="w-full bg-amber-600 hover:bg-amber-700 text-white font-semibold py-3 px-6 rounded-lg transition-colors">Weiter</button>
            </div>
        </div>
    </div>

    <div id="multiplayerLobbyModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 px-4">
        <div class="bg-white rounded-xl p-8 max-w-lg w-full mx-4 shadow-2xl text-center">
            <h2 id="lobbyTitle" class="text-2xl font-bold text-amber-800 mb-4">Warte auf Mitspieler...</h2>
            <p id="lobbyText" class="text-gray-700 mb-6">Teile diesen Link mit deinem Freund, um das Spiel zu starten:</p>
            <div class="bg-gray-100 p-3 rounded-lg border border-gray-300">
                <input id="shareLink" type="text" class="w-full bg-transparent text-center text-blue-600" readonly>
            </div>
            <button onclick="window.copyShareLink()" class="mt-4 bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-6 rounded-lg transition-colors">Link kopieren</button>
            <div id="qrCodeContainer" class="mt-4 flex justify-center"></div>
            <p id="lobbyStatus" class="mt-6 text-green-600 font-semibold"></p>
        </div>
    </div>

    <div id="gameContainer" class="hidden max-w-6xl mx-auto px-4 py-4 relative">
        <div id="animationContainer" class="absolute top-0 left-0 w-full h-full pointer-events-none overflow-hidden"></div>
        <div class="max-w-md mx-auto mb-1 space-y-1">
            <div class="flex justify-center space-x-2">
                <div id="playerScoreBox" class="w-1/2 bg-white rounded-xl shadow-lg p-2 text-center relative">
                    <p id="playerNameDisplay" class="text-base font-bold text-amber-600 truncate"></p>
                    <p class="text-sm text-gray-500">Karten: <span id="playerCards" class="font-semibold">15</span></p>
                </div>
                <div id="opponentScoreBox" class="w-1/2 bg-white rounded-xl shadow-lg p-2 text-center">
                    <p id="opponentNameDisplay" class="text-base font-bold text-red-600">Computer</p>
                    <p class="text-sm text-gray-500">Karten: <span id="aiCards" class="font-semibold">15</span></p>
                </div>
            </div>
            <div class="w-full bg-gray-200 rounded-full h-4 relative overflow-hidden border border-gray-300">
                <div id="statusBar" class="h-full rounded-l-full transition-all duration-500" style="width: 50%; background-color: #f59e0b;"></div>
                <div class="absolute inset-0 flex justify-center items-center">
                    <div class="w-0.5 h-full bg-white opacity-75"></div>
                </div>
            </div>
        </div>

        <div class="flex justify-center space-x-2 sm:space-x-2 mb-4 max-w-md mx-auto">
            <div class="text-center w-1/2">
                <div id="playerCard" class="relative aspect-[20/38] perspective-1000"></div>
            </div>
            <div class="text-center w-1/2">
                <div id="aiCard" class="relative aspect-[20/38] perspective-1000"></div>
            </div>
        </div>

        <div class="bg-white rounded-xl shadow-lg px-1 pt-1 pb-0.5 mt-4 text-center mx-auto flex flex-col items-center max-w-md w-full min-h-[6rem]">
            <div id="turnIndicator" class="hidden text-sm font-semibold p-1"></div>
            <div id="attributeSelection" class=""><h3 class="text-base font-semibold text-gray-700 mb-1">W√§hle eine Eigenschaft!</h3></div>
            <div id="resultDisplay" class="hidden flex flex-col flex-grow w-full px-2">
                <h3 id="resultText" class="text-lg sm:text-xl font-bold"></h3>
                <p id="resultDetails" class="text-xs sm:text-sm text-gray-600 mt-auto pb-0.5"></p>
            </div>
            <div id="nextRoundButton" class="hidden w-full mt-2">
                <button onclick="window.nextRound()" class="w-full bg-amber-600 hover:bg-amber-800 text-white font-bold py-3 px-8 rounded-xl transition-colors">‚û°Ô∏è N√§chster Zug</button>
            </div>
        </div>
    </div>

    <div id="reflectionModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 px-4">
        <div class="bg-white rounded-xl p-8 max-w-lg w-full mx-4 shadow-2xl text-center">
            <h2 class="text-2xl font-bold text-amber-800 mb-4">üéâ Super gespielt! Zeit zum Reflektieren!</h2>
            <p id="reflectionQuestion" class="text-gray-700 mb-6 text-left"></p>
            <textarea id="reflectionAnswer" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-amber-500 focus:border-transparent min-h-[100px]" placeholder="Deine Begr√ºndung..."></textarea>
            <button onclick="window.showFinalWinScreen()" class="mt-6 w-full bg-amber-600 hover:bg-amber-700 text-white font-semibold py-3 px-6 rounded-lg transition-colors">Weiter zum Ergebnis</button>
        </div>
    </div>

    <div id="gameOverModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div class="bg-white rounded-xl p-8 max-w-md w-full mx-4 shadow-2xl text-center">
            <h2 id="gameOverTitle" class="text-3xl font-bold mb-3"></h2>
            <p id="gameOverText" class="text-gray-600 mb-6"></p>
            <div class="space-y-2">
                <button onclick="window.showLeaderboard()" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-6 rounded-lg">üèÜ Bestenliste anzeigen</button>
                <button onclick="window.resetGame()" class="w-full bg-amber-600 hover:bg-amber-700 text-white font-semibold py-3 px-6 rounded-lg">üîÑ Neues Spiel</button>
            </div>
        </div>
    </div>

    <div id="leaderboardModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div class="bg-white rounded-xl p-8 max-w-md w-full mx-4 shadow-2xl">
            <h2 class="text-2xl font-bold text-amber-800 mb-6 text-center">üèÜ Bestenliste</h2>
            <div id="leaderboardList" class="space-y-1 mb-6"></div>
            <button onclick="window.closeLeaderboard()" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-semibold py-3 px-6 rounded-lg">Schlie√üen</button>
        </div>
    </div>

    <div id="infoModal" class="hidden fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 px-4">
        <div class="bg-white rounded-xl p-8 max-w-lg w-full mx-4 shadow-2xl relative">
            <button onclick="window.closeInfoModal()" class="absolute top-2 right-3 text-2xl text-gray-400 hover:text-gray-600">&times;</button>
            <h2 id="infoModalTitle" class="text-2xl font-bold text-amber-800 mb-4">Wissenswertes</h2>
            <div id="infoModalContent" class="text-gray-700 space-y-2 max-h-[60vh] overflow-y-auto"></div>
        </div>
    </div>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
    import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, serverTimestamp, deleteDoc, collection, query, orderBy, limit, getDocs, increment } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

    const firebaseConfig = {
        apiKey: "AIzaSyCyRXl8-JPr1xTXPDi1VG-eQk6fOnTpqUI", //ACHTUNG: Aus Sicherheitsgr√ºnden im Produktivbetrieb pr√ºfen!
        authDomain: "holzquartett-3a177.firebaseapp.com",
        projectId: "holzquartett-3a177",
        storageBucket: "holzquartett-3a177.appspot.com",
        messagingSenderId: "1081595025073",
        appId: "1:1081595025073:web:bc571fffb6e4f20b27f490",
        measurementId: "G-HKLWFJE83K"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);
    const appId = firebaseConfig.projectId;

    let gameMode = null, gameId = null, localPlayerId = null, unsubscribeGame = null;
    let localGameState = {}; let hasCopiedShareLink = false; let isMuted = false;
    let roundSoundPlayed = false; let gameWinSoundPlayed = false;
    let localPlayerName = "Spieler";

    // === Sounds ===
    const sounds = {
      flip: new Audio('https://github.com/aufdemholzweg/holzquartett/raw/refs/heads/main/sounds/Spielzug%20gewonnen.wav'),
      turnWin: new Audio('https://github.com/aufdemholzweg/holzquartett/raw/refs/heads/main/sounds/Spielzug%20gewonnen.wav'),
      gameWin: new Audio('https://github.com/aufdemholzweg/holzquartett/raw/refs/heads/main/sounds/Spiel%20gewonnen.wav'),
      lose: new Audio('https://cdn.pixabay.com/audio/2021/08/04/audio_1c5c0cce22.mp3')
    };
    sounds.flip.volume = 0.5; sounds.turnWin.volume = 0.7; sounds.gameWin.volume = 0.7; sounds.lose.volume = 0.4;

    function playSound(s){ if(isMuted) return; s.currentTime=0; s.play().catch(()=>{}); }
    function playSoundDelayed(s,ms){ if(isMuted) return; setTimeout(()=>playSound(s),ms); }

    // === Kartendaten ===
    const woodCards = [{name:"Eiche",dk:2,haerte:85,quellenSchwindenRadial:4.0,dichte:650,gewicht:12000},{name:"Buche",dk:5,haerte:80,quellenSchwindenRadial:5.8,dichte:720,gewicht:14000},{name:"Kiefer",dk:3,haerte:40,quellenSchwindenRadial:3.5,dichte:520,gewicht:11000},{name:"Fichte",dk:4,haerte:35,quellenSchwindenRadial:3.6,dichte:450,gewicht:11000},{name:"Tanne",dk:4,haerte:38,quellenSchwindenRadial:3.5,dichte:460,gewicht:10000},{name:"L√§rche",dk:3,haerte:55,quellenSchwindenRadial:3.7,dichte:590,gewicht:12000},{name:"Birke",dk:5,haerte:60,quellenSchwindenRadial:5.4,dichte:650,gewicht:13000},{name:"Ahorn",dk:5,haerte:75,quellenSchwindenRadial:4.8,dichte:630,gewicht:12500},{name:"Esche",dk:5,haerte:90,quellenSchwindenRadial:4.9,dichte:700,gewicht:13000},{name:"Kirsche",dk:3,haerte:70,quellenSchwindenRadial:4.0,dichte:600,gewicht:11500},{name:"Nussbaum",dk:3,haerte:65,quellenSchwindenRadial:4.0,dichte:640,gewicht:12000},{name:"Douglasie",dk:3,haerte:45,quellenSchwindenRadial:3.5,dichte:510,gewicht:12000},{name:"Zeder",dk:2,haerte:42,quellenSchwindenRadial:2.8,dichte:480,gewicht:9500},{name:"Mahagoni",dk:2,haerte:55,quellenSchwindenRadial:3.0,dichte:550,gewicht:10500},{name:"Teak",dk:1,haerte:60,quellenSchwindenRadial:2.5,dichte:650,gewicht:11000},{name:"Bambus",dk:4,haerte:50,quellenSchwindenRadial:3.0,dichte:400,gewicht:18000},{name:"Pappel",dk:5,haerte:25,quellenSchwindenRadial:4.5,dichte:380,gewicht:9000},{name:"Weide",dk:5,haerte:30,quellenSchwindenRadial:4.0,dichte:420,gewicht:8000},{name:"Linde",dk:5,haerte:35,quellenSchwindenRadial:3.8,dichte:530,gewicht:9000},{name:"Ulme",dk:3,haerte:75,quellenSchwindenRadial:4.5,dichte:680,gewicht:11500},{name:"Kastanie",dk:2,haerte:50,quellenSchwindenRadial:3.5,dichte:600,gewicht:10000},{name:"Robinie",dk:1,haerte:80,quellenSchwindenRadial:3.0,dichte:730,gewicht:15000},{name:"Hemlock",dk:4,haerte:40,quellenSchwindenRadial:3.6,dichte:500,gewicht:10000},{name:"Zypresse",dk:2,haerte:48,quellenSchwindenRadial:3.0,dichte:520,gewicht:9000},{name:"Redwood",dk:2,haerte:35,quellenSchwindenRadial:2.8,dichte:400,gewicht:8500},{name:"Hickory",dk:3,haerte:95,quellenSchwindenRadial:5.5,dichte:750,gewicht:14000},{name:"Wenge",dk:2,haerte:88,quellenSchwindenRadial:3.8,dichte:880,gewicht:16000},{name:"Zebrano",dk:3,haerte:70,quellenSchwindenRadial:4.0,dichte:750,gewicht:13000},{name:"Palisander",dk:2,haerte:82,quellenSchwindenRadial:3.0,dichte:850,gewicht:16000},{name:"Ebenholz",dk:1,haerte:98,quellenSchwindenRadial:3.2,dichte:1200,gewicht:16500}];
    const woodInfoMap = {"Eiche":{info:"Eiche ...",bildBaum:"https://github.com/aufdemholzweg/holzquartett/blob/main/images/eiche_1.jpg?raw=true",bildQuerschnitt:"https://github.com/aufdemholzweg/holzquartett/blob/main/images/eiche_2.jpg?raw=true"},"Buche":{info:"Buche ...",bildBaum:"https://github.com/aufdemholzweg/holzquartett/blob/main/images/buche_1.jpg?raw=true",bildQuerschnitt:"https://github.com/aufdemholzweg/holzquartett/blob/main/images/buche_2.jpg?raw=true"},"Ebenholz":{info:"Ebenholz ...",bildBaum:"https://github.com/aufdemholzweg/holzquartett/blob/main/images/ebenholz_1.jpg?raw=true",bildQuerschnitt:"https://github.com/aufdemholzweg/holzquartett/blob/main/images/ebenholz_2.jpg?raw=true"}};
    const allWoodInfoKeys = ["Kiefer","Fichte","Tanne","L√§rche","Birke","Ahorn","Esche","Kirsche","Nussbaum","Douglasie","Zeder","Mahagoni","Teak","Bambus","Pappel","Weide","Linde","Ulme","Kastanie","Robinie","Hemlock","Zypresse","Redwood","Hickory","Wenge","Zebrano","Palisander"];
    allWoodInfoKeys.forEach(k=>{ if(!woodInfoMap[k]) woodInfoMap[k]={info:`Keine Detailinfo f√ºr ${k} verf√ºgbar.`,bildBaum:'',bildQuerschnitt:''}; });

    const reflectionQuestions=[
        "Du hast gewonnen! Welche Eigenschaft (z.B. Rohdichte) hieltest du bei deiner Siegerkarte f√ºr besonders stark und warum?",
        "Gut gek√§mpft! Welche Karte des Gegners war besonders schwer zu schlagen und welche Eigenschaft hat sie so stark gemacht?",
        "Sieg! Erinnere dich an eine Runde: Warum hast du dich f√ºr genau DIESE Eigenschaft (z.B. H√§rte) entschieden und nicht f√ºr eine andere?"
    ];
    
    // mapping, name, und ob ein h√∂herer Wert besser ist
    const attributeInfo={
        dk:{icon:'üõ°Ô∏è',name:'Dauerhaftigkeit (DK)',color:'text-sky-700', higherIsBetter: false},
        haerte:{icon:'üíé',name:'Druckfestigkeit (N/mm¬≤)',color:'text-blue-700', higherIsBetter: true},
        quellenSchwindenRadial:{icon:'‚ÜîÔ∏è',name:'Quellen/Schwinden (%)',color:'text-indigo-700', higherIsBetter: false},
        dichte:{icon:'‚öñÔ∏è',name:'Rohdichte (kg/m¬≥)',color:'text-violet-700', higherIsBetter: true},
        gewicht:{icon:'üèãÔ∏è',name:'E-Modul (N/mm¬≤)',color:'text-purple-700', higherIsBetter: true}
    };

    // Globales Spiel-Objekt f√ºr AI-Modus
    let aiGame={
        playerName: 'Spieler',
        playerCards: [],
        aiCards: [],
        currentPlayerCard: null,
        currentAiCard: null,
        roundInProgress: false,
        turn: 'player'
    };

    // === Initialisierung ===
    document.addEventListener('DOMContentLoaded', async () => {
        const splashScreen=document.getElementById('splashScreen');
        const setupModal=document.getElementById('setupModal');
        // Splash Screen ausblenden
        setTimeout(()=>{
            splashScreen.classList.add('opacity-0'); 
            setTimeout(()=>{
                splashScreen.classList.add('hidden'); 
                const urlParams=new URLSearchParams(window.location.search); 
                const gameIdFromUrl=urlParams.get('game'); 
                if(!gameIdFromUrl){ // Nur SetupModal zeigen, wenn keinem Spiel beigetreten wird
                    setupModal.classList.remove('hidden'); 
                    setupModal.classList.add('flex');
                }
            }, 700);
        }, 3000); // Splash f√ºr 3s

        // Sound-Toggle Logik
        const soundToggle=document.getElementById('soundToggle');
        const saved=localStorage.getItem('holzquartett_isMuted'); 
        isMuted=saved==='true';
        if(soundToggle){ 
            soundToggle.checked=!isMuted; 
            soundToggle.addEventListener('change',(e)=>{ 
                isMuted=!e.target.checked; 
                localStorage.setItem('holzquartett_isMuted',isMuted); 
                if(!isMuted){ playSound(sounds.flip); } 
            }); 
        }

        // Firebase Auth
        try { 
            await signInAnonymously(auth);
        } catch(e) {
            console.error("Anonyme Anmeldung fehlgeschlagen:", e);
        }
        
        onAuthStateChanged(auth,(user)=>{
            if(user){ 
                localPlayerId=user.uid; 
                const urlParams=new URLSearchParams(window.location.search); 
                const gameIdFromUrl=urlParams.get('game'); 
                if(gameIdFromUrl){ 
                    gameId=gameIdFromUrl; 
                    gameMode='multiplayer'; 
                    window.showNamePrompt('join'); // Zeige Namens-Modal f√ºr Beitritt
                }
            } else {
                console.log("Nicht angemeldet.");
            }
        });
    });

    // Aufr√§umen beim Verlassen der Seite (Multiplayer)
    window.addEventListener('beforeunload', async () => {
         if (gameMode === 'multiplayer' && gameId && localPlayerId) {
             const gameRef = doc(db, "games", gameId);
             const playerStatusPath = `players.${localPlayerId}.status`;
             await updateDoc(gameRef, { [playerStatusPath]: "offline" }).catch(() => {});
         }
    });

    // --- (BEGINN DER FEHLENDEN LOGIK) ---

    // === Globale window. Funktionen (f√ºr HTML onclick) ===

    /**
     * Startet das Spiel neu, indem die Seite neugeladen wird.
     */
    window.resetGame = () => {
        if (unsubscribeGame) unsubscribeGame(); // Listener schlie√üen
        window.location.href = window.location.pathname; // URL ohne Parameter neuladen
    }

    /**
     * Zeigt das Namens-Eingabe-Modal an.
     * @param {string} mode - Der gew√§hlte Modus ('ai', 'multiplayer', 'join').
     */
    window.showNamePrompt = (mode) => {
        document.getElementById('setupModal').classList.add('hidden');
        document.getElementById('setupModal').classList.remove('flex');
        const nameModal = document.getElementById('nameModal');
        nameModal.classList.remove('hidden');
        nameModal.classList.add('flex');
        
        const nameInput = document.getElementById('playerName');
        const savedName = localStorage.getItem('holzquartett_playerName');
        if (savedName) nameInput.value = savedName;

        const submitButton = document.getElementById('nameSubmitButton');
        
        // Event-Listener nur einmal hinzuf√ºgen (indem wir ihn klonen)
        const newSubmitButton = submitButton.cloneNode(true);
        submitButton.parentNode.replaceChild(newSubmitButton, submitButton);

        newSubmitButton.onclick = async () => {
            localPlayerName = nameInput.value.trim() || "Spieler";
            localStorage.setItem('holzquartett_playerName', localPlayerName);
            
            nameModal.classList.add('hidden');
            nameModal.classList.remove('flex');

            if (mode === 'ai') {
                startGameAI(localPlayerName);
            } else if (mode === 'multiplayer') {
                await createGame(localPlayerName);
            } else if (mode === 'join') {
                await joinGame(gameId, localPlayerName);
            }
        };
    }

    /**
     * Kopiert den Share-Link in die Zwischenablage.
     */
    window.copyShareLink = () => {
        const shareLink = document.getElementById('shareLink');
        shareLink.select();
        document.execCommand('copy');
        hasCopiedShareLink = true;
        document.getElementById('lobbyStatus').textContent = "Link kopiert!";
        setTimeout(() => {
            if (document.getElementById('lobbyStatus').textContent === "Link kopiert!") {
                document.getElementById('lobbyStatus').textContent = "";
            }
        }, 2000);
    }

    /**
     * Startet die n√§chste Runde (nur AI-Modus).
     */
    window.nextRound = () => {
        if (gameMode !== 'ai' || aiGame.roundInProgress) return;
        
        aiGame.roundInProgress = false;
        
        // Verstecke Ergebnis-Displays
        document.getElementById('resultDisplay').classList.add('hidden');
        document.getElementById('resultDisplay').classList.remove('flex');
        document.getElementById('nextRoundButton').classList.add('hidden');
        
        // Setze Karten-Animationen zur√ºck
        document.getElementById('playerCard').querySelector('.card-3d').classList.remove('card-flipped', 'animate-glow-win', 'animate-glow-lose');
        document.getElementById('aiCard').querySelector('.card-3d').classList.remove('card-flipped', 'animate-glow-win', 'animate-glow-lose');
        
        // Setze Status-Bar Animation zur√ºck
        document.getElementById('statusBar').classList.remove('status-flash-win', 'status-flash-lose');
        document.getElementById('playerScoreBox').classList.remove('animate-glow-win', 'animate-glow-lose');
        document.getElementById('opponentScoreBox').classList.remove('animate-glow-win', 'animate-glow-lose');
        
        // Aktualisiere die UI f√ºr die neue Runde
        updateAIUI();

        // Wenn AI dran ist, soll sie automatisch w√§hlen
        if (aiGame.turn === 'ai') {
            document.getElementById('attributeSelection').classList.add('hidden');
            document.getElementById('turnIndicator').classList.remove('hidden');
            document.getElementById('turnIndicator').textContent = "Computer w√§hlt...";
            setTimeout(aiSelectAttribute, 2000); // AI denkt 2s nach
        }
    }

    /**
     * W√§hlt ein Attribut im AI-Modus.
     * @param {string} key - Der Schl√ºssel des Attributs (z.B. 'haerte').
     */
    window.selectAttributeAI = (key) => {
        if (gameMode !== 'ai' || aiGame.turn !== 'player' || aiGame.roundInProgress) return;

        aiGame.roundInProgress = true;
        document.getElementById('attributeSelection').classList.add('hidden');

        // Hole Karten
        const playerCard = aiGame.currentPlayerCard;
        const aiCard = aiGame.currentAiCard;
        const playerValue = playerCard[key];
        const aiValue = aiCard[key];
        
        const { name: attrName, higherIsBetter } = attributeInfo[key];

        // AI-Karte aufdecken
        const aiCardInner = document.getElementById('aiCard').querySelector('.card-3d');
        aiCardInner.classList.add('card-flipped');
        playSound(sounds.flip);

        let winner = 'draw';
        if (higherIsBetter) {
            if (playerValue > aiValue) winner = 'player';
            else if (playerValue < aiValue) winner = 'ai';
        } else { // Niedriger ist besser
            if (playerValue < aiValue) winner = 'player';
            else if (playerValue > aiValue) winner = 'ai';
        }

        // Ergebnis anzeigen
        const resultText = document.getElementById('resultText');
        const resultDetails = document.getElementById('resultDetails');
        const playerBox = document.getElementById('playerScoreBox');
        const aiBox = document.getElementById('opponentScoreBox');
        const statusBar = document.getElementById('statusBar');

        document.getElementById('resultDisplay').classList.remove('hidden');
        document.getElementById('resultDisplay').classList.add('flex');

        if (winner === 'player') {
            resultText.textContent = "üéâ Du gewinnst die Runde!";
            resultText.className = "text-lg sm:text-xl font-bold text-green-600";
            resultDetails.textContent = `Dein Wert: ${playerValue} | Computer: ${aiValue}`;
            playerBox.classList.add('animate-glow-win');
            aiBox.classList.add('animate-glow-lose');
            statusBar.classList.add('status-flash-win');
            playSoundDelayed(sounds.turnWin, 500);
            createStarAnimation(playerBox);
        } else if (winner === 'ai') {
            resultText.textContent = "üò• Computer gewinnt.";
            resultText.className = "text-lg sm:text-xl font-bold text-red-600";
            resultDetails.textContent = `Dein Wert: ${playerValue} | Computer: ${aiValue}`;
            playerBox.classList.add('animate-glow-lose');
            aiBox.classList.add('animate-glow-win');
            statusBar.classList.add('status-flash-lose');
            playSoundDelayed(sounds.lose, 500);
            createStarAnimation(aiBox);
        } else {
            resultText.textContent = "ü§î Unentschieden!";
            resultText.className = "text-lg sm:text-xl font-bold text-gray-600";
            resultDetails.textContent = `Beide: ${playerValue}`;
        }

        // Verz√∂gerung vor dem Verarbeiten des Ergebnisses
        setTimeout(() => processAIFightResult(winner), 2000);
    }
    
    /**
     * W√§hlt ein Attribut im Multiplayer-Modus.
     * @param {string} key - Der Schl√ºssel des Attributs (z.B. 'haerte').
     */
    window.selectAttributeMP = async (key) => {
        if (gameMode !== 'multiplayer' || !localGameState || localGameState.roundInProgress) return;
        if (localGameState.turn !== localPlayerId) return; // Nicht am Zug

        try {
            const gameRef = doc(db, "games", gameId);
            await updateDoc(gameRef, {
                lastAction: `${localPlayerName} hat ${attributeInfo[key].name} gew√§hlt.`,
                selectedAttribute: key,
                roundInProgress: true,
                "players.p1.showCard": true, // Beide Karten aufdecken
                "players.p2.showCard": true
            });
            // Der onSnapshot-Handler (onGameUpdate) √ºbernimmt den Rest
        } catch (e) {
            console.error("Fehler beim W√§hlen des Attributs:", e);
        }
    }

    /**
     * Zeigt die Bestenliste an.
     */
    window.showLeaderboard = async () => {
        document.getElementById('gameOverModal').classList.add('hidden');
        document.getElementById('gameOverModal').classList.remove('flex');
        
        const leaderboardList = document.getElementById('leaderboardList');
        leaderboardList.innerHTML = '<p class="text-center">Lade...</p>';
        document.getElementById('leaderboardModal').classList.remove('hidden');
        document.getElementById('leaderboardModal').classList.add('flex');

        try {
            const q = query(collection(db, "leaderboard"), orderBy("wins", "desc"), limit(10));
            const querySnapshot = await getDocs(q);
            
            if (querySnapshot.empty) {
                leaderboardList.innerHTML = '<p class="text-center text-gray-500">Noch keine Eintr√§ge.</p>';
                return;
            }

            let html = '';
            let rank = 1;
            querySnapshot.forEach((doc) => {
                const data = doc.data();
                const medal = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : `${rank}.`;
                html += `
                    <div class="flex justify-between items-center bg-gray-50 p-3 rounded-lg">
                        <span class="font-bold text-amber-700 w-12 text-left">${medal}</span>
                        <span class="font-semibold text-gray-800 flex-1 truncate">${doc.id}</span>
                        <span class="font-bold text-gray-600">${data.wins} Siege</span>
                    </div>`;
                rank++;
            });
            leaderboardList.innerHTML = html;
        } catch (e) {
            console.error("Fehler beim Laden der Bestenliste:", e);
            leaderboardList.innerHTML = '<p class="text-center text-red-500">Fehler beim Laden.</p>';
        }
    }

    /**
     * Schlie√üt die Bestenliste.
     */
    window.closeLeaderboard = () => {
        document.getElementById('leaderboardModal').classList.add('hidden');
        document.getElementById('leaderboardModal').classList.remove('flex');
        // Zeige Game-Over-Screen wieder, wenn Spielmodus AI war
        if (gameMode === 'ai') {
             document.getElementById('gameOverModal').classList.remove('hidden');
             document.getElementById('gameOverModal').classList.add('flex');
        }
    }
    
    /**
     * Zeigt das Info-Modal f√ºr eine Karte.
     * @param {string} woodName - Name der Holzart.
     */
    window.showInfoModal = (woodName) => {
        const info = woodInfoMap[woodName] || woodInfoMap["Eiche"]; // Fallback
        
        document.getElementById('infoModalTitle').textContent = `Wissenswertes: ${woodName}`;
        
        let contentHtml = `<p>${info.info}</p>`;
        if (info.bildBaum) {
            contentHtml += `<img src="${info.bildBaum}" alt="${woodName} Baum" class="rounded-lg mt-4 w-full h-auto object-cover">`;
        }
        if (info.bildQuerschnitt) {
            contentHtml += `<img src="${info.bildQuerschnitt}" alt="${woodName} Querschnitt" class="rounded-lg mt-4 w-full h-auto object-cover">`;
        }
        
        document.getElementById('infoModalContent').innerHTML = contentHtml;
        document.getElementById('infoModal').classList.remove('hidden');
        document.getElementById('infoModal').classList.add('flex');
    }

    /**
     * Schlie√üt das Info-Modal.
     */
    window.closeInfoModal = () => {
        document.getElementById('infoModal').classList.add('hidden');
        document.getElementById('infoModal').classList.remove('flex');
    }
    
    /**
     * Zeigt den finalen Gewinn-Screen (nach der Reflexion).
     */
    window.showFinalWinScreen = () => {
        document.getElementById('reflectionModal').classList.add('hidden');
        document.getElementById('reflectionModal').classList.remove('flex');
        
        // Speichere die Reflexions-Antwort (optional, hier nur geloggt)
        const reflectionAnswer = document.getElementById('reflectionAnswer').value;
        console.log("Reflexion:", reflectionAnswer);
        
        // Zeige Game-Over-Modal
        document.getElementById('gameOverModal').classList.remove('hidden');
        document.getElementById('gameOverModal').classList.add('flex');
        
        // Aktualisiere Bestenliste
        updateLeaderboard(aiGame.playerName, true);
    }
    
    // === AI Modus Logik ===

    /**
     * Startet ein Spiel gegen den Computer.
     * @param {string} playerName - Der Name des Spielers.
     */
    function startGameAI(playerName) {
        gameMode = 'ai';
        aiGame.playerName = playerName;
        gameWinSoundPlayed = false;

        // Karten mischen und verteilen
        const shuffledCards = shuffle([...woodCards]);
        const mid = Math.ceil(shuffledCards.length / 2);
        aiGame.playerCards = shuffledCards.slice(0, mid);
        aiGame.aiCards = shuffledCards.slice(mid);

        aiGame.turn = 'player'; // Spieler beginnt immer
        aiGame.roundInProgress = false;

        // UI vorbereiten
        document.getElementById('setupModal').classList.add('hidden');
        document.getElementById('setupModal').classList.remove('flex');
        document.getElementById('gameContainer').classList.remove('hidden');
        document.getElementById('playerNameDisplay').textContent = playerName;
        document.getElementById('opponentNameDisplay').textContent = "Computer";

        updateAIUI();
    }

    /**
     * Aktualisiert die Benutzeroberfl√§che im AI-Modus.
     */
    function updateAIUI() {
        if (aiGame.playerCards.length === 0 || aiGame.aiCards.length === 0) {
            endGameAI();
            return;
        }

        // Karten z√§hlen
        const totalCards = aiGame.playerCards.length + aiGame.aiCards.length;
        const playerPercent = (aiGame.playerCards.length / totalCards) * 100;
        document.getElementById('playerCards').textContent = aiGame.playerCards.length;
        document.getElementById('aiCards').textContent = aiGame.aiCards.length;
        
        // Statusleiste
        const statusBar = document.getElementById('statusBar');
        statusBar.style.width = `${playerPercent}%`;
        statusBar.style.backgroundColor = playerPercent > 50 ? '#f59e0b' : (playerPercent === 50 ? '#9ca3af' : '#ef4444');

        // Aktuelle Karten setzen
        aiGame.currentPlayerCard = aiGame.playerCards[0];
        aiGame.currentAiCard = aiGame.aiCards[0];
        
        // Karten rendern
        const isPlayerTurn = aiGame.turn === 'player';
        renderCard('playerCard', aiGame.currentPlayerCard, isPlayerTurn, 'ai');
        renderCard('aiCard', aiGame.currentAiCard, false, 'ai'); // AI-Karte immer verdeckt/nicht klickbar
        
        // Aktionen anzeigen
        if (isPlayerTurn) {
            document.getElementById('attributeSelection').classList.remove('hidden');
            document.getElementById('turnIndicator').classList.add('hidden');
        } else {
            // (Wird in nextRound() gehandhabt)
        }
    }

    /**
     * Verarbeitet das Ergebnis einer AI-Runde.
     * @param {string} winner - 'player', 'ai', or 'draw'.
     */
    function processAIFightResult(winner) {
        const playerCard = aiGame.playerCards.shift(); // Nimm Karte von oben
        const aiCard = aiGame.aiCards.shift();

        if (winner === 'player') {
            aiGame.playerCards.push(playerCard, aiCard); // Gewinner bekommt beide
            aiGame.turn = 'player'; // Gewinner ist dran
        } else if (winner === 'ai') {
            aiGame.aiCards.push(aiCard, playerCard);
            aiGame.turn = 'ai';
        } else { // Unentschieden
            aiGame.playerCards.push(playerCard); // Beide bekommen ihre Karte zur√ºck
            aiGame.aiCards.push(aiCard);
            // aiGame.turn bleibt unver√§ndert
        }
        
        // Pr√ºfen ob Spiel vorbei ist
        if (aiGame.playerCards.length === 0 || aiGame.aiCards.length === 0) {
            endGameAI();
        } else {
            // "N√§chste Runde" Button anzeigen
            document.getElementById('nextRoundButton').classList.remove('hidden');
        }
    }

    /**
     * Die AI w√§hlt ein Attribut (einfache Strategie).
     */
    function aiSelectAttribute() {
        if (aiGame.turn !== 'ai' || aiGame.roundInProgress) return;
        
        const card = aiGame.currentAiCard;
        let bestAttr = '';
        let bestScore = -Infinity;

        // Einfache AI: W√§hlt Attribut mit dem "besten" Wert
        // (ignoriert, ob hoch oder niedrig besser ist, nimmt einfach h√∂chsten Wert relativ zum Typ)
        // Eine bessere AI w√ºrde Werte normalisieren oder R√§nge vergleichen.
        
        const attributes = Object.keys(attributeInfo);
        const chosenAttr = attributes[Math.floor(Math.random() * attributes.length)]; // W√§hlt zuf√§llig

        // Starte den Kampf, als ob der Spieler gew√§hlt h√§tte
        // (Wir m√ºssen die UI anpassen, um die AI-Auswahl zu zeigen)
        
        const { name: attrName } = attributeInfo[chosenAttr];
        document.getElementById('resultText').textContent = `Computer w√§hlt ${attrName}!`;
        document.getElementById('resultText').className = "text-lg sm:text-xl font-bold text-gray-700";
        document.getElementById('resultDetails').textContent = "...";
        document.getElementById('resultDisplay').classList.remove('hidden');
        document.getElementById('resultDisplay').classList.add('flex');
        
        // Simuliere Klick
        setTimeout(() => {
            // Wir rufen selectAttributeAI auf, aber es pr√ºft ob 'player' dran ist.
            // Wir m√ºssen die Logik duplizieren oder anpassen.
            // L√∂sung: Wir "f√§lschen" den Gewinner-Check von selectAttributeAI
            
            aiGame.roundInProgress = true;
            document.getElementById('attributeSelection').classList.add('hidden');
            document.getElementById('turnIndicator').classList.add('hidden');

            const playerCard = aiGame.currentPlayerCard;
            const aiCard = aiGame.currentAiCard;
            const playerValue = playerCard[chosenAttr];
            const aiValue = aiCard[chosenAttr];
            
            const { higherIsBetter } = attributeInfo[chosenAttr];

            // Spielerkarte aufdecken (falls sie noch nicht offen war, sollte sie aber)
            const playerCardInner = document.getElementById('playerCard').querySelector('.card-3d');
            playerCardInner.classList.add('card-flipped'); // Deckt sie auf, falls sie es nicht ist
            playSound(sounds.flip);

            let winner = 'draw';
            if (higherIsBetter) {
                if (aiValue > playerValue) winner = 'ai';
                else if (aiValue < playerValue) winner = 'player';
            } else { // Niedriger ist besser
                if (aiValue < playerValue) winner = 'ai';
                else if (aiValue > playerValue) winner = 'player';
            }

            // Ergebnis anzeigen
            const resultText = document.getElementById('resultText');
            const resultDetails = document.getElementById('resultDetails');
            const playerBox = document.getElementById('playerScoreBox');
            const aiBox = document.getElementById('opponentScoreBox');
            const statusBar = document.getElementById('statusBar');

            if (winner === 'player') {
                resultText.textContent = "üéâ Du gewinnst die Runde!";
                resultText.className = "text-lg sm:text-xl font-bold text-green-600";
                resultDetails.textContent = `Dein Wert: ${playerValue} | Computer: ${aiValue}`;
                playerBox.classList.add('animate-glow-win');
                aiBox.classList.add('animate-glow-lose');
                statusBar.classList.add('status-flash-win');
                playSoundDelayed(sounds.turnWin, 500);
                createStarAnimation(playerBox);
            } else if (winner === 'ai') {
                resultText.textContent = "üò• Computer gewinnt.";
                resultText.className = "text-lg sm:text-xl font-bold text-red-600";
                resultDetails.textContent = `Dein Wert: ${playerValue} | Computer: ${aiValue}`;
                playerBox.classList.add('animate-glow-lose');
                aiBox.classList.add('animate-glow-win');
                statusBar.classList.add('status-flash-lose');
                playSoundDelayed(sounds.lose, 500);
                createStarAnimation(aiBox);
            } else {
                resultText.textContent = "ü§î Unentschieden!";
                resultText.className = "text-lg sm:text-xl font-bold text-gray-600";
                resultDetails.textContent = `Beide: ${playerValue}`;
            }

            // Verz√∂gerung vor dem Verarbeiten des Ergebnisses
            setTimeout(() => processAIFightResult(winner), 2000);
            
        }, 1500); // Zeige "Computer w√§hlt..." f√ºr 1.5s
    }

    /**
     * Beendet das AI-Spiel.
     */
    function endGameAI() {
        const playerWon = aiGame.playerCards.length > 0;
        
        document.getElementById('gameOverTitle').textContent = playerWon ? "üå≥ Du hast HOLZEN! üå≥" : "GAME OVER";
        document.getElementById('gameOverText').textContent = playerWon ? 
            `Gl√ºckwunsch, ${aiGame.playerName}! Du hast alle Karten gewonnen.` : 
            "Der Computer hat alle deine Karten gewonnen. Versuchs nochmal!";
            
        if (playerWon) {
            if (!gameWinSoundPlayed) {
                playSound(sounds.gameWin);
                gameWinSoundPlayed = true;
            }
            // Zeige Reflexions-Modal
            showReflection();
        } else {
            if (!gameWinSoundPlayed) {
                playSound(sounds.lose); // (oder einen spezifischen Game-Lose-Sound)
                gameWinSoundPlayed = true;
            }
            // Bei Niederlage direkt Game Over und Leaderboard aktualisieren (mit 0 Wins)
            document.getElementById('gameOverModal').classList.remove('hidden');
            document.getElementById('gameOverModal').classList.add('flex');
            updateLeaderboard(aiGame.playerName, false);
        }
    }
    
    // === Multiplayer Modus Logik ===

    /**
     * Erstellt ein neues Multiplayer-Spiel.
     * @param {string} playerName - Name des Host-Spielers.
     */
    async function createGame(playerName) {
        gameMode = 'multiplayer';
        gameWinSoundPlayed = false;
        
        // Lade-Modal anzeigen (Lobby)
        const lobby = document.getElementById('multiplayerLobbyModal');
        lobby.classList.remove('hidden');
        lobby.classList.add('flex');
        
        gameId = generateGameId();
        const gameRef = doc(db, "games", gameId);
        
        // Karten mischen und verteilen
        const shuffledCards = shuffle([...woodCards]);
        const mid = Math.ceil(shuffledCards.length / 2);
        const hostCards = shuffledCards.slice(0, mid);
        const guestCards = shuffledCards.slice(mid);

        const newGame = {
            gameId: gameId,
            hostId: localPlayerId,
            status: "waiting", // waiting, active, finished
            turn: localPlayerId, // Host f√§ngt an
            lastAction: "Spiel erstellt. Warte auf Spieler 2...",
            selectedAttribute: null,
            roundInProgress: false,
            createdAt: serverTimestamp(),
            players: {
                [localPlayerId]: {
                    name: playerName,
                    cards: hostCards,
                    status: "online",
                    showCard: false
                },
                // p2 wird beim Beitreten hinzugef√ºgt
            }
        };

        try {
            await setDoc(gameRef, newGame);
            
            // URL und QR-Code anzeigen
            const url = `${window.location.origin}${window.location.pathname}?game=${gameId}`;
            document.getElementById('shareLink').value = url;
            QRCode.toCanvas(document.getElementById('qrCodeContainer'), url, { width: 128 });

            // Auf Spiel-Updates lauschen
            listenToGameUpdates(gameId);

        } catch (e) {
            console.error("Fehler beim Erstellen des Spiels:", e);
            lobby.innerHTML = "Fehler beim Erstellen des Spiels. Bitte neu laden.";
        }
    }

    /**
     * Tritt einem Multiplayer-Spiel bei.
     * @param {string} joinGameId - Die ID des Spiels, dem beigetreten wird.
     * @param {string} playerName - Name des beitretenden Spielers.
     */
    async function joinGame(joinGameId, playerName) {
        gameMode = 'multiplayer';
        gameWinSoundPlayed = false;
        const gameRef = doc(db, "games", joinGameId);
        
        try {
            const gameSnap = await getDoc(gameRef);
            if (!gameSnap.exists()) {
                alert("Spiel nicht gefunden!");
                window.resetGame();
                return;
            }
            
            const gameData = gameSnap.data();
            
            // Pr√ºfen, ob Spiel voll ist
            if (gameData.players && Object.keys(gameData.players).length >= 2 && !gameData.players[localPlayerId]) {
                alert("Dieses Spiel ist bereits voll.");
                window.resetGame();
                return;
            }
            
            // Wenn Spieler bereits Teil des Spiels ist (Reconnect)
            if (gameData.players[localPlayerId]) {
                 await updateDoc(gameRef, {
                    [`players.${localPlayerId}.status`]: "online"
                });
            } else { 
                // Neu beitreten
                // Die Karten des Gastgebers sind schon im Dokument, wir m√ºssen die restlichen nehmen.
                const hostCards = gameData.players[gameData.hostId].cards;
                const allCardNames = woodCards.map(c => c.name);
                const hostCardNames = hostCards.map(c => c.name);
                const guestCardNames = allCardNames.filter(name => !hostCardNames.includes(name));
                const guestCards = woodCards.filter(card => guestCardNames.includes(card.name));
                
                await updateDoc(gameRef, {
                    status: "active",
                    lastAction: `${playerName} ist beigetreten!`,
                    [`players.${localPlayerId}`]: {
                        name: playerName,
                        cards: guestCards,
                        status: "online",
                        showCard: false
                    }
                });
            }
            
            // Lobby ausblenden und Spiel starten
            document.getElementById('multiplayerLobbyModal').classList.add('hidden');
            document.getElementById('multiplayerLobbyModal').classList.remove('flex');
            document.getElementById('gameContainer').classList.remove('hidden');

            listenToGameUpdates(joinGameId);
            
        } catch (e) {
            console.error("Fehler beim Beitreten:", e);
            alert("Fehler beim Beitreten zum Spiel.");
            window.resetGame();
        }
    }
    
    /**
     * Startet den Firestore Listener f√ºr Spiel-Updates.
     * @param {string} listenGameId - Die ID des zu h√∂renden Spiels.
     */
    function listenToGameUpdates(listenGameId) {
        if (unsubscribeGame) unsubscribeGame(); // Alten Listener stoppen
        
        const gameRef = doc(db, "games", listenGameId);
        unsubscribeGame = onSnapshot(gameRef, (doc) => {
            if (!doc.exists()) {
                // Spiel wurde gel√∂scht (z.B. Host links)
                alert("Der Host hat das Spiel verlassen.");
                window.resetGame();
                return;
            }
            
            localGameState = doc.data();
            updateMultiplayerUI(localGameState);
        });
    }

    /**
     * Aktualisiert die UI basierend auf dem Multiplayer-GameState.
     * @param {object} state - Der aktuelle Spielstatus von Firestore.
     */
    function updateMultiplayerUI(state) {
        if (!state.players || Object.keys(state.players).length < 2) {
            // Warte auf 2. Spieler in der Lobby
            document.getElementById('lobbyStatus').textContent = state.lastAction;
            return;
        }

        // Lobby ausblenden, falls noch offen
        document.getElementById('multiplayerLobbyModal').classList.add('hidden');
        document.getElementById('multiplayerLobbyModal').classList.remove('flex');
        document.getElementById('gameContainer').classList.remove('hidden');

        // Spieler und Gegner identifizieren
        const player = state.players[localPlayerId];
        const opponentId = Object.keys(state.players).find(id => id !== localPlayerId);
        const opponent = state.players[opponentId];
        
        if (!player || !opponent) {
            // Warten auf Initialisierung
            return;
        }

        // Spiel vorbei?
        if (player.cards.length === 0 || opponent.cards.length === 0) {
            endGameMP(player.cards.length > 0, player.name);
            return;
        }

        // UI-Elemente aktualisieren
        document.getElementById('playerNameDisplay').textContent = player.name;
        document.getElementById('opponentNameDisplay').textContent = opponent.name;
        
        const totalCards = player.cards.length + opponent.cards.length;
        const playerPercent = (player.cards.length / totalCards) * 100;
        document.getElementById('playerCards').textContent = player.cards.length;
        document.getElementById('aiCards').textContent = opponent.cards.length; // Nutzt AI-Karten-ID
        
        document.getElementById('statusBar').style.width = `${playerPercent}%`;

        // Aktuelle Karten
        const playerCard = player.cards[0];
        const opponentCard = opponent.cards[0];
        
        // Karten rendern
        const isPlayerTurn = state.turn === localPlayerId;
        renderCard('playerCard', playerCard, isPlayerTurn, 'mp');
        renderCard('aiCard', opponentCard, false, 'mp'); // Gegnerkarte nie klickbar
        
        // Karten aufdecken?
        if (player.showCard) {
            document.getElementById('playerCard').querySelector('.card-3d').classList.add('card-flipped');
        }
        if (opponent.showCard) {
            document.getElementById('aiCard').querySelector('.card-3d').classList.add('card-flipped');
        }

        // Anzeige, wer dran ist
        const turnIndicator = document.getElementById('turnIndicator');
        const attrSelection = document.getElementById('attributeSelection');
        
        if (state.roundInProgress) {
            attrSelection.classList.add('hidden');
            turnIndicator.classList.add('hidden'); // Ergebnis wird stattdessen angezeigt
        } else {
            if (isPlayerTurn) {
                attrSelection.classList.remove('hidden');
                turnIndicator.classList.add('hidden');
            } else {
                attrSelection.classList.add('hidden');
                turnIndicator.classList.remove('hidden');
                turnIndicator.textContent = `${opponent.name} w√§hlt...`;
            }
        }
        
        // Ergebnis anzeigen, wenn Runde vorbei
        const resultDisplay = document.getElementById('resultDisplay');
        const nextRoundBtn = document.getElementById('nextRoundButton');
        
        if (state.selectedAttribute && !state.roundInProgress) {
            // Diese Runde ist vorbei, warte auf n√§chste Runde
            // (Logik, um Runden-Ergebnis zu verarbeiten)
            processMPRound(state, player, opponent, state.selectedAttribute);
            
        } else if (state.selectedAttribute && state.roundInProgress) {
             // Attribut wurde gew√§hlt, Runde wird ausgewertet
            resultDisplay.classList.remove('hidden');
            resultDisplay.classList.add('flex');
            document.getElementById('resultText').textContent = "Werte werden verglichen...";
            document.getElementById('resultDetails').textContent = state.lastAction;
        } else {
            // Normales Spiel
            resultDisplay.classList.add('hidden');
            resultDisplay.classList.remove('flex');
            nextRoundBtn.classList.add('hidden');
        }
    }

    /**
     * Verarbeitet das Runden-Ergebnis im MP (nur vom Host).
     */
    async function processMPRound(state, player, opponent, attributeKey) {
        if (state.hostId !== localPlayerId) return; // Nur Host wertet aus
        if (state.roundInProgress) return; // Runde wird bereits verarbeitet
        
        // Verhindere doppelte Ausf√ºhrung
        await updateDoc(doc(db, "games", gameId), { roundInProgress: true });

        const playerCard = player.cards[0];
        const opponentCard = opponent.cards[0];
        
        const playerValue = playerCard[attributeKey];
        const opponentValue = opponentCard[attributeKey];
        const { higherIsBetter } = attributeInfo[attributeKey];

        let winnerId = 'draw';
        if (higherIsBetter) {
            if (playerValue > opponentValue) winnerId = localPlayerId;
            else if (playerValue < opponentValue) winnerId = Object.keys(state.players).find(id => id !== localPlayerId);
        } else {
            if (playerValue < opponentValue) winnerId = localPlayerId;
            else if (playerValue > opponentValue) winnerId = Object.keys(state.players).find(id => id !== localPlayerId);
        }

        let newPlayerCards = [...player.cards];
        let newOpponentCards = [...opponent.cards];
        const pCard = newPlayerCards.shift();
        const oCard = newOpponentCards.shift();
        
        let newTurn = state.turn;
        let lastAction = "";

        if (winnerId === localPlayerId) {
            newPlayerCards.push(pCard, oCard);
            newTurn = localPlayerId;
            lastAction = `${player.name} gewinnt die Runde!`;
        } else if (winnerId === 'draw') {
            newPlayerCards.push(pCard);
            newOpponentCards.push(oCard);
            lastAction = "Unentschieden!";
        } else {
            newOpponentCards.push(oCard, pCard);
            newTurn = winnerId;
            lastAction = `${opponent.name} gewinnt die Runde!`;
        }
        
        // Update an Firebase
        setTimeout(async () => {
             await updateDoc(doc(db, "games", gameId), {
                [`players.${localPlayerId}.cards`]: newPlayerCards,
                [`players.${opponent.id}.cards`]: newOpponentCards, // opponent.id existiert nicht, muss korrigiert werden
                turn: newTurn,
                lastAction: lastAction,
                selectedAttribute: null,
                roundInProgress: false,
                "players.p1.showCard": false, // Karten wieder umdrehen
                "players.p2.showCard": false
             });
        }, 3000); // 3s Ergebnis anzeigen
        
        // FIXME: `opponent.id` ist falsch. Muss `opponentId` aus `updateMultiplayerUI` sein.
        // Diese Funktion wird umstrukturiert werden m√ºssen, da `player` und `opponent`
        // relativ zum lokalen Spieler sind, aber die DB-Struktur absolut ist (p1, p2).
        
        // HINWEIS: Die Multiplayer-Logik hier ist vereinfacht und muss
        // robust gegen Race Conditions und die spezifische DB-Struktur (p1 vs p2) gemacht werden.
        // Die Logik in `updateMPRound` (falls vorhanden) ist entscheidend.
        // Oben genannte Logik ist ein schneller Entwurf.
    }

    /**
     * Beendet das MP-Spiel.
     * @param {boolean} playerWon - Ob der lokale Spieler gewonnen hat.
     * @param {string} playerName - Name des lokalen Spielers.
     */
    function endGameMP(playerWon, playerName) {
        if (unsubscribeGame) unsubscribeGame(); // Listener stoppen
        
        document.getElementById('gameOverTitle').textContent = playerWon ? "üå≥ Du hast HOLZEN! üå≥" : "GAME OVER";
        document.getElementById('gameOverText').textContent = playerWon ? 
            `Gl√ºckwunsch, ${playerName}! Du hast alle Karten gewonnen.` : 
            "Dein Gegner hat alle deine Karten gewonnen.";
            
        if (playerWon && !gameWinSoundPlayed) {
            playSound(sounds.gameWin);
            gameWinSoundPlayed = true;
        } else if (!gameWinSoundPlayed) {
            playSound(sounds.lose);
            gameWinSoundPlayed = true;
        }
        
        // Im MP keine Reflexion, direkt zum Game Over
        document.getElementById('gameOverModal').classList.remove('hidden');
        document.getElementById('gameOverModal').classList.add('flex');
        
        // Im MP (aktuell) keine Bestenliste
        document.querySelector('#gameOverModal button[onclick="window.showLeaderboard()"]').classList.add('hidden');
        
        // Spiel-Dokument l√∂schen (optional, nur Host)
        // if(localGameState.hostId === localPlayerId) {
        //     deleteDoc(doc(db, "games", gameId));
        // }
    }

    // === UI Rendering & Hilfsfunktionen ===

    /**
     * Rendert eine Spielkarte in den DOM.
     * @param {string} containerId - 'playerCard' or 'aiCard'.
     * @param {object} card - Das Karten-Datenobjekt.
     * @param {boolean} isPlayerTurn - Ob der Spieler am Zug ist (macht Karte klickbar).
     * @param {string} mode - 'ai' or 'mp'.
     */
    function renderCard(containerId, card, isPlayerTurn, mode) {
        const container = document.getElementById(containerId);
        if (!card) {
            container.innerHTML = ""; // Leeren, wenn keine Karte da ist
            return;
        }
        
        const isPlayerCard = containerId === 'playerCard';
        // Im AI-Modus ist die Spielerkarte immer aufgedeckt
        // Im MP-Modus steuert `showCard` dies (wird extern gehandhabt)
        const startFlipped = !isPlayerCard && mode === 'ai'; 

        let attributesHtml = '';
        for (const [key, { icon, name, color, higherIsBetter }] of Object.entries(attributeInfo)) {
            const value = card[key];
            
            // Klickbar machen, wenn es die Spielerkarte ist, der Spieler dran ist und der Modus passt
            const clickable = isPlayerCard && isPlayerTurn && (mode === 'ai' || mode === 'mp');
            const onClickFunction = mode === 'ai' ? `window.selectAttributeAI('${key}')` : `window.selectAttributeMP('${key}')`;
            
            attributesHtml += `
                <li ${clickable ? `onclick="${onClickFunction}"` : ''} 
                    class="flex justify-between items-center p-1.5 sm:p-2 rounded-lg transition-colors ${clickable ? 'cursor-pointer hover:bg-amber-100' : ''}">
                    <div class="flex items-center space-x-1.5 min-w-0">
                        <span class="text-sm sm:text-lg">${icon}</span>
                        <span class="text-xs sm:text-sm font-medium ${color} truncate">${name}</span>
                    </div>
                    <span class="text-sm sm:text-base font-bold text-gray-800">${value}</span>
                </li>`;
        }

        const infoHtml = woodInfoMap[card.name] ? `<button onclick="window.showInfoModal('${card.name}')" class="absolute top-1 right-1 text-base sm:text-xl font-bold text-gray-500 hover:text-blue-600 transition-colors w-6 h-6 rounded-full bg-white bg-opacity-50 flex items-center justify-center">i</button>` : '';

        const cardHtml = `
            <div class="card-3d w-full h-full ${startFlipped ? 'card-flipped' : ''}">
                <div class="card-front card-background rounded-xl shadow-lg border-2 border-amber-300 overflow-hidden p-2 sm:p-3 flex flex-col">
                    <div class="text-center relative">
                        <h3 class="text-lg sm:text-xl font-bold text-gray-900 truncate">${card.name}</h3>
                        ${infoHtml}
                    </div>
                    <div class="w-full aspect-[4/3] bg-gray-200 rounded-md my-1 sm:my-2 overflow-hidden">
                        <img src="${(woodInfoMap[card.name] && woodInfoMap[card.name].bildBaum) || 'https://via.placeholder.com/200x150?text=Holz'}" class="w-full h-full object-cover" alt="${card.name}">
                    </div>
                    <ul class="space-y-0.5 sm:space-y-1 text-sm flex-grow">
                        ${attributesHtml}
                    </ul>
                </div>
                
                <div class="card-back rounded-xl shadow-lg border-2 border-gray-400">
                    </div>
            </div>
        `;
        container.innerHTML = cardHtml;
    }

    /**
     * Mischt ein Array (Fisher-Yates).
     * @param {Array} array - Das zu mischende Array.
     * @returns {Array} Das gemischte Array.
     */
    function shuffle(array) {
        let currentIndex = array.length, randomIndex;
        while (currentIndex != 0) {
            randomIndex = Math.floor(Math.random() * currentIndex);
            currentIndex--;
            [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
        }
        return array;
    }

    /**
     * Zeigt das Reflexions-Modal an.
     */
    function showReflection() {
        const question = reflectionQuestions[Math.floor(Math.random() * reflectionQuestions.length)];
        document.getElementById('reflectionQuestion').textContent = question;
        document.getElementById('reflectionAnswer').value = "";
        
        document.getElementById('reflectionModal').classList.remove('hidden');
        document.getElementById('reflectionModal').classList.add('flex');
    }

    /**
     * Aktualisiert die Bestenliste in Firestore.
     * @param {string} playerName - Der Name des Spielers.
     * @param {boolean} didWin - Ob der Spieler gewonnen hat.
     */
    async function updateLeaderboard(playerName, didWin) {
        if (!playerName || playerName === "Spieler") return; // Standardnamen nicht speichern

        const playerRef = doc(db, "leaderboard", playerName);
        try {
            const docSnap = await getDoc(playerRef);
            if (docSnap.exists()) {
                await updateDoc(playerRef, {
                    wins: didWin ? increment(1) : increment(0),
                    losses: didWin ? increment(0) : increment(1),
                    lastPlayed: serverTimestamp()
                });
            } else {
                await setDoc(playerRef, {
                    wins: didWin ? 1 : 0,
                    losses: didWin ? 0 : 1,
                    lastPlayed: serverTimestamp()
                });
            }
        } catch (e) {
            console.error("Fehler beim Aktualisieren der Bestenliste: ", e);
        }
    }
    
    /**
     * Erzeugt eine Stern-Animation √ºber einem Ziel-Element.
     * @param {HTMLElement} targetBox - Das HTML-Element (z.B. Score-Box), √ºber dem der Stern erscheinen soll.
     */
    function createStarAnimation(targetBox) {
        const rect = targetBox.getBoundingClientRect();
        const animContainer = document.getElementById('animationContainer');
        
        const star = document.createElement('div');
        star.className = 'falling-star';
        star.textContent = '‚≠ê';
        
        // Startposition (√ºber der Box)
        const startX = rect.left + rect.width / 2 - window.scrollX;
        const startY = rect.top - window.scrollY;
        
        // Endposition (in der Box)
        const endY = startY + 50; // F√§llt 50px nach unten
        
        star.style.left = `${startX}px`;
        star.style.top = `${startY}px`;
        star.style.setProperty('--end-y', `${endY}px`);

        animContainer.appendChild(star);
        
        setTimeout(() => {
            star.remove();
        }, 1200); // Dauer der Animation
    }

    /**
     * Generiert eine zuf√§llige Spiel-ID.
     * @returns {string} Eine 6-stellige alphanumerische ID.
     */
    function generateGameId() {
        return Math.random().toString(36).substring(2, 8).toUpperCase();
    }
    
    // --- (ENDE DER FEHLENDEN LOGIK) ---

</script>
</body>
</html>
