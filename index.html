<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Holz-Quartett</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            font-weight: 300;
        }

        .card-3d {
            transform-style: preserve-3d;
            transition: transform 0.6s;
        }

        .card-flipped {
            transform: rotateY(180deg);
        }

        .card-front, .card-back {
            backface-visibility: hidden;
            position: absolute;
            width: 100%;
            height: 100%;
        }

        .card-back {
            transform: rotateY(180deg);
            background-image: url('https://raw.githubusercontent.com/aufdemholzweg/holzquartett/65fd843a4db1ee434faaf81a32f77951a5afb72a/images/background_card.jpg');
            background-size: cover;
            background-position: center;
        }

        .wood-texture {
            background: linear-gradient(45deg, #8B4513 25%, transparent 25%),
                        linear-gradient(-45deg, #8B4513 25%, transparent 25%),
                        linear-gradient(45deg, transparent 75%, #8B4513 75%),
                        linear-gradient(-45deg, transparent 75%, #8B4513 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            background-color: #D2B48C;
            opacity: 0.1;
        }

        .animate-pop-in {
            animation: pop-in 0.5s ease-out forwards;
        }

        .animate-glow-win {
            animation: glow-win 1.2s ease-out;
        }

        .animate-glow-lose {
            animation: glow-lose 1.2s ease-out;
        }

        @keyframes pop-in {
            0% { transform: scale(0); opacity: 0; }
            70% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); }
        }

        @keyframes glow-win {
            0% { box-shadow: 0 0 0 0 rgba(74, 222, 128, 0); } /* green-400 */
            50% { box-shadow: 0 0 30px 15px rgba(74, 222, 128, 0.6); }
            100% { box-shadow: 0 0 0 0 rgba(74, 222, 128, 0); }
        }

        @keyframes glow-lose {
            0% { box-shadow: 0 0 0 0 rgba(248, 113, 113, 0); } /* red-400 */
            50% { box-shadow: 0 0 30px 15px rgba(248, 113, 113, 0.6); }
            100% { box-shadow: 0 0 0 0 rgba(248, 113, 113, 0); }
        }

        .hover-lift:hover {
            transform: translateY(-4px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.15);
        }

        .status-flash-win {
            animation: flash-green 1.2s ease-out;
        }
        .status-flash-lose {
            animation: flash-red 1.2s ease-out;
        }

        @keyframes flash-green {
          50% { background-color: #22c55e; box-shadow: 0 0 15px #22c55e; }
        }
        @keyframes flash-red {
          50% { background-color: #ef4444; box-shadow: 0 0 15px #ef4444; }
        }

        .falling-star {
            position: absolute;
            font-size: 7rem; /* 112px */
            z-index: 100;
            animation: fall-and-fade 1.2s ease-in forwards;
        }

        @keyframes fall-and-fade {
            0% { transform: translateY(-30px) scale(1.5); opacity: 0; }
            30% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(var(--end-y)) scale(0.3); opacity: 0; }
        }
        .card-background {
            background-image: url('https://raw.githubusercontent.com/aufdemholzweg/holzquartett/e7cfc18394e2e7f2d0b91df1138b0d7bc7930699/images/background_front.jpg');
            background-size: cover;
            background-position: center;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-amber-50 to-orange-100 min-h-screen">
    <header class="bg-white shadow-sm border-b-2 border-amber-200">
        <div class="max-w-6xl mx-auto px-4 p-3">
            <h1 class="text-2xl font-bold text-amber-800 text-center">üå≥ Holz-Quartett</h1>
            <p class="text-xs text-gray-500 text-center mt-1">von Christopher Lehr, in Verbindung mit meiner Masterarbeit</p>
        </div>
    </header>

    <div id="setupModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div class="bg-white rounded-xl p-8 max-w-md w-full mx-4 shadow-2xl text-center">
            <h2 class="text-2xl font-bold text-amber-800 mb-6">Spielmodus w√§hlen</h2>
            <div class="space-y-4">
                <button onclick="window.showNamePrompt('ai')" class="w-full bg-amber-600 hover:bg-amber-700 text-white font-semibold py-4 px-6 rounded-lg transition-colors text-lg">
                    üéÆ Gegen Computer spielen
                </button>
                <button onclick="window.showNamePrompt('multiplayer')" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-4 px-6 rounded-lg transition-colors text-lg">
                    üßë‚Äçü§ù‚Äçüßë Mit Freund online spielen
                </button>
            </div>
        </div>
    </div>

    <div id="nameModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div class="bg-white rounded-xl p-8 max-w-md w-full mx-4 shadow-2xl">
            <h2 class="text-2xl font-bold text-amber-800 mb-6 text-center">Dein Name</h2>
            <div class="space-y-3">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Bitte gib deinen Namen ein:</label>
                    <input type="text" id="playerName" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-amber-500 focus:border-transparent" placeholder="Spielername">
                </div>
                <button id="nameSubmitButton" class="w-full bg-amber-600 hover:bg-amber-700 text-white font-semibold py-3 px-6 rounded-lg transition-colors">
                    Weiter
                </button>
            </div>
        </div>
    </div>

    <div id="multiplayerLobbyModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 px-4">
        <div class="bg-white rounded-xl p-8 max-w-lg w-full mx-4 shadow-2xl text-center">
            <h2 id="lobbyTitle" class="text-2xl font-bold text-amber-800 mb-4">Warte auf Mitspieler...</h2>
            <p id="lobbyText" class="text-gray-700 mb-6">Teile diesen Link mit deinem Freund, um das Spiel zu starten:</p>
            <div class="bg-gray-100 p-3 rounded-lg border border-gray-300">
                <input id="shareLink" type="text" class="w-full bg-transparent text-center text-blue-600" readonly>
            </div>
            <button onclick="window.copyShareLink()" class="mt-4 bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-6 rounded-lg transition-colors">
                Link kopieren
            </button>
            <p id="lobbyStatus" class="mt-6 text-green-600 font-semibold"></p>
        </div>
    </div>


    <div id="gameContainer" class="hidden max-w-6xl mx-auto px-4 py-4 relative">
        <div id="animationContainer" class="absolute top-0 left-0 w-full h-full pointer-events-none overflow-hidden"></div>
        <div class="max-w-md mx-auto mb-3 space-y-1">
            <div class="flex justify-center space-x-2">
                <div id="playerScoreBox" class="w-1/2 bg-white rounded-xl shadow-lg p-2 text-center relative">
                    <p id="playerNameDisplay" class="text-base font-bold text-amber-600 truncate"></p>
                    <p class="text-sm text-gray-500">Karten: <span id="playerCards" class="font-semibold">15</span></p>
                </div>
                <div class="w-1/2 bg-white rounded-xl shadow-lg p-2 text-center">
                    <p id="opponentNameDisplay" class="text-base font-bold text-red-600">Computer</p>
                    <p class="text-sm text-gray-500">Karten: <span id="aiCards" class="font-semibold">15</span></p>
                </div>
            </div>
            <div class="w-full bg-gray-200 rounded-full h-4 relative overflow-hidden border border-gray-300">
                <div id="statusBar" class="h-full rounded-l-full transition-all duration-500" style="width: 50%; background-color: #f59e0b;"></div>
                <div class="absolute inset-0 flex justify-center items-center">
                    <div class="w-0.5 h-full bg-white opacity-75"></div>
                </div>
            </div>
        </div>

        <div class="flex justify-center space-x-2 sm:space-x-2 mb-4 max-w-md mx-auto">
            <div class="text-center w-1/2">
                <div id="playerCard" class="relative aspect-[20/38] perspective-1000"></div>
            </div>
            <div class="text-center w-1/2">
                <div id="aiCard" class="relative aspect-[20/38] perspective-1000"></div>
            </div>
        </div>

        <div class="bg-white rounded-xl shadow-lg p-1 mt-4 text-center mx-auto flex flex-col items-center justify-center max-w-md w-full">
            <div id="turnIndicator" class="hidden text-sm font-semibold p-2"></div>
            <div id="attributeSelection" class="">
                 <h3 class="text-lg font-semibold text-gray-700">W√§hle eine Eigenschaft!</h3>
            </div>
            <div id="nextRoundButton" class="hidden w-full mb-1">
                 <button onclick="window.nextRound()" class="w-full bg-amber-600 hover:bg-amber-800 text-white font-bold py-3 px-8 rounded-xl transition-colors">
                      ‚û°Ô∏è N√§chster Zug
                 </button>
             </div>
            <div id="resultDisplay" class="hidden">
                 <h3 id="resultText" class="text-xl font-bold mb-1"></h3>
                 <p id="resultDetails" class="text-sm text-gray-600"></p>
            </div>
        </div>
    </div>

    <div id="reflectionModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 px-4">
        <div class="bg-white rounded-xl p-8 max-w-lg w-full mx-4 shadow-2xl text-center">
            <h2 class="text-2xl font-bold text-amber-800 mb-4">üéâ Super gespielt! Zeit zum Reflektieren!</h2>
            <p id="reflectionQuestion" class="text-gray-700 mb-6 text-left"></p>
            <textarea id="reflectionAnswer" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-amber-500 focus:border-transparent min-h-[100px]" placeholder="Deine Begr√ºndung..."></textarea>
            <button onclick="window.showFinalWinScreen()" class="mt-6 w-full bg-amber-600 hover:bg-amber-700 text-white font-semibold py-3 px-6 rounded-lg transition-colors">
                Weiter zum Ergebnis
            </button>
        </div>
    </div>

    <div id="gameOverModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div class="bg-white rounded-xl p-8 max-w-md w-full mx-4 shadow-2xl text-center">
            <h2 id="gameOverTitle" class="text-3xl font-bold mb-3"></h2>
            <p id="gameOverText" class="text-gray-600 mb-6"></p>
            <div class="space-y-2">
                <button onclick="window.showLeaderboard()" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-6 rounded-lg">
                    üèÜ Bestenliste anzeigen
                </button>
                <button onclick="window.resetGame()" class="w-full bg-amber-600 hover:bg-amber-700 text-white font-semibold py-3 px-6 rounded-lg">
                    üîÑ Neues Spiel
                </button>
            </div>
        </div>
    </div>

    <div id="leaderboardModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div class="bg-white rounded-xl p-8 max-w-md w-full mx-4 shadow-2xl">
            <h2 class="text-2xl font-bold text-amber-800 mb-6 text-center">üèÜ Bestenliste</h2>
            <div id="leaderboardList" class="space-y-1 mb-6"></div>
            <button onclick="window.closeLeaderboard()" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-semibold py-3 px-6 rounded-lg">
                Schlie√üen
            </button>
        </div>
    </div>

    <div id="infoModal" class="hidden fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 px-4">
        <div class="bg-white rounded-xl p-8 max-w-lg w-full mx-4 shadow-2xl relative">
            <button onclick="window.closeInfoModal()" class="absolute top-2 right-3 text-2xl text-gray-400 hover:text-gray-600">&times;</button>
            <h2 id="infoModalTitle" class="text-2xl font-bold text-amber-800 mb-4">Wissenswertes</h2>
            <div id="infoModalContent" class="text-gray-700 space-y-2 max-h-[60vh] overflow-y-auto"></div>
        </div>
    </div>

    <script type="module">
        // ===== Firebase Imports =====
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, serverTimestamp, deleteDoc, collection, query, orderBy, limit, getDocs, increment } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

        // ===== Firebase Config =====
        const firebaseConfig = {
            apiKey: "AIzaSyCyRXl8-JPr1xTXPDi1VG-eQk6fOnTpqUI", // Consider securing this key
            authDomain: "holzquartett-3a177.firebaseapp.com",
            projectId: "holzquartett-3a177",
            storageBucket: "holzquartett-3a177.appspot.com",
            messagingSenderId: "1081595025073",
            appId: "1:1081595025073:web:bc571fffb6e4f20b27f490",
            measurementId: "G-HKLWFJE83K"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        const appId = firebaseConfig.projectId;

        // ===== Global State =====
        let gameMode = null;
        let gameId = null;
        let localPlayerId = null;
        let unsubscribeGame = null;
        let localGameState = {};
        let hasCopiedShareLink = false;

        // Sound Effects
        const sounds = {
            flip: new Audio('https://cdn.pixabay.com/audio/2022/03/15/audio_139083c224.mp3'),
            win: new Audio('https://cdn.pixabay.com/audio/2022/11/22/audio_2c5552a862.mp3')
        };
        sounds.flip.volume = 0.5; // Optional: Adjust volume
        sounds.win.volume = 0.4;  // Optional: Adjust volume

        function playSound(sound) {
            sound.currentTime = 0; // Rewind to start
            sound.play().catch(e => console.log("Sound playback error:", e)); // Play and catch potential errors
        }
        let roundSoundPlayed = false; // Flag for multiplayer to prevent sound spam

        // ===== Wood Data =====
        const woodCards = [
            {name: "Eiche", dk: 2, haerte: 85, quellenSchwindenRadial: 4.0, dichte: 650, gewicht: 12000}, {name: "Buche", dk: 5, haerte: 80, quellenSchwindenRadial: 5.8, dichte: 720, gewicht: 14000}, {name: "Kiefer", dk: 3, haerte: 40, quellenSchwindenRadial: 3.5, dichte: 520, gewicht: 11000}, {name: "Fichte", dk: 4, haerte: 35, quellenSchwindenRadial: 3.6, dichte: 450, gewicht: 11000}, {name: "Tanne", dk: 4, haerte: 38, quellenSchwindenRadial: 3.5, dichte: 460, gewicht: 10000}, {name: "L√§rche", dk: 3, haerte: 55, quellenSchwindenRadial: 3.7, dichte: 590, gewicht: 12000}, {name: "Birke", dk: 5, haerte: 60, quellenSchwindenRadial: 5.4, dichte: 650, gewicht: 13000}, {name: "Ahorn", dk: 5, haerte: 75, quellenSchwindenRadial: 4.8, dichte: 630, gewicht: 12500}, {name: "Esche", dk: 5, haerte: 90, quellenSchwindenRadial: 4.9, dichte: 700, gewicht: 13000}, {name: "Kirsche", dk: 3, haerte: 70, quellenSchwindenRadial: 4.0, dichte: 600, gewicht: 11500}, {name: "Nussbaum", dk: 3, haerte: 65, quellenSchwindenRadial: 4.0, dichte: 640, gewicht: 12000}, {name: "Douglasie", dk: 3, haerte: 45, quellenSchwindenRadial: 3.5, dichte: 510, gewicht: 12000}, {name: "Zeder", dk: 2, haerte: 42, quellenSchwindenRadial: 2.8, dichte: 480, gewicht: 9500}, {name: "Mahagoni", dk: 2, haerte: 55, quellenSchwindenRadial: 3.0, dichte: 550, gewicht: 10500}, {name: "Teak", dk: 1, haerte: 60, quellenSchwindenRadial: 2.5, dichte: 650, gewicht: 11000}, {name: "Bambus", dk: 4, haerte: 50, quellenSchwindenRadial: 3.0, dichte: 400, gewicht: 18000}, {name: "Pappel", dk: 5, haerte: 25, quellenSchwindenRadial: 4.5, dichte: 380, gewicht: 9000}, {name: "Weide", dk: 5, haerte: 30, quellenSchwindenRadial: 4.0, dichte: 420, gewicht: 8000}, {name: "Linde", dk: 5, haerte: 35, quellenSchwindenRadial: 3.8, dichte: 530, gewicht: 9000}, {name: "Ulme", dk: 3, haerte: 75, quellenSchwindenRadial: 4.5, dichte: 680, gewicht: 11500}, {name: "Kastanie", dk: 2, haerte: 50, quellenSchwindenRadial: 3.5, dichte: 600, gewicht: 10000}, {name: "Robinie", dk: 1, haerte: 80, quellenSchwindenRadial: 3.0, dichte: 730, gewicht: 15000}, {name: "Hemlock", dk: 4, haerte: 40, quellenSchwindenRadial: 3.6, dichte: 500, gewicht: 10000}, {name: "Zypresse", dk: 2, haerte: 48, quellenSchwindenRadial: 3.0, dichte: 520, gewicht: 9000}, {name: "Redwood", dk: 2, haerte: 35, quellenSchwindenRadial: 2.8, dichte: 400, gewicht: 8500}, {name: "Hickory", dk: 3, haerte: 95, quellenSchwindenRadial: 5.5, dichte: 750, gewicht: 14000}, {name: "Wenge", dk: 2, haerte: 88, quellenSchwindenRadial: 3.8, dichte: 880, gewicht: 16000}, {name: "Zebrano", dk: 3, haerte: 70, quellenSchwindenRadial: 4.0, dichte: 750, gewicht: 13000}, {name: "Palisander", dk: 2, haerte: 82, quellenSchwindenRadial: 3.0, dichte: 850, gewicht: 16000}, {name: "Ebenholz", dk: 1, haerte: 98, quellenSchwindenRadial: 3.2, dichte: 1200, gewicht: 16500}
        ];

        const woodInfo = { /* ... (woodInfo data remains unchanged) ... */
             "Eiche": { info: `Eiche (QE) Die Eiche z√§hlt zu den bedeutendsten heimischen Laubh√∂lzern Europas. Ihr Holz ist hart, schwer und sehr dauerhaft, was sie zu einem bevorzugten Werkstoff im Innen‚Äë und Au√üenbereich macht. Besonders charakteristisch sind die hohen Gerbstoffanteile, die das Holz widerstandsf√§hig gegen Pilze und Sch√§dlinge machen ‚Äì gleichzeitig k√∂nnen sie beim Kontakt mit Eisen zu Verf√§rbungen f√ºhren. Eichenholz ist grobporig und zeigt einen deutlichen √úbergang zwischen Fr√ºh- und Sp√§tholz, wodurch die Jahresringe klar sichtbar sind. Diese ausgepr√§gte Maserung sorgt f√ºr eine markante, lebendige Optik. Verwendung: M√∂bel, Fu√üb√∂den, Treppen, Fassdauben (z.‚ÄØB. f√ºr Weinf√§sser), Schiffbau, Terrassen, Br√ºcken, Fachwerk. Funfact: Bereits in der Antike galt die Eiche als Symbol f√ºr St√§rke und Best√§ndigkeit ‚Äì sie ziert bis heute zahlreiche Wappen und M√ºnzen.`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/eiche_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/eiche_2.jpg?raw=true" },
             "Buche": { info: `Buche (BU) Die Buche ist ein gleichm√§√üig strukturiertes Hartholz heimischer W√§lder. Ihr Holz ist z√§h, biegsam und relativ harzarm, wodurch es sich sehr gut f√ºr M√∂bel und Parkett eignet. Buchenholz ist ringporig mit mittelgro√üen Poren im Fr√ºhholz und dichterem Sp√§tholz, sodass die √úberg√§nge dezent sichtbar sind ‚Äì die Jahresringe sind gut erkennbar, aber nicht grob. Verwendung: M√∂bel, Parkett, Furniere, Sperrholz, Innenausbau. Funfact: Buchenholz war lange Zeit typisch f√ºrs Wagenrad ‚Äì wegen seiner Kombination aus Z√§higkeit und Elastizit√§t.`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/buche_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/buche_2.jpg?raw=true" },
             "Kiefer": { info: `Kiefer (KI) Kiefer ist ein weit verbreitetes Nadelholz mit markanter Jahresringstruktur. Es ist weich, harzhaltig und relativ leicht zu bearbeiten. Das Holz zeigt keine ausgepr√§gten gro√üen Poren wie Laubh√∂lzer, sondern eine eher gleichm√§√üige Zellstruktur ‚Äì Jahresringe und Harzkan√§le sind sichtbar. Verwendung: Bauholz, Dachst√ºhle, Innenausbau, M√∂bel, Paneele. Funfact: Kiefernharz wurde fr√ºher als Klebstoff oder als Bestandteil von Salben und Dichtungsmaterialien verwendet.`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/kiefer_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/kiefer_2.jpg?raw=true" },
             "Fichte": { info: `Fichte (FI) Fichte ist ein klassisches Bauholz mit guter Festigkeit bei geringem Gewicht. Es l√§sst sich leicht bearbeiten und vielfach einsetzen. Das Holz weist eine feine Zellstruktur auf, ohne gro√üe Poren ‚Äì Jahresringe sind erkennbar, aber nicht grob. Verwendung: Bauholz, Innenverkleidung, Dach, M√∂bel, Paneele. Funfact: In vielen Gebirgsregionen war Fichtenholz √ºber Jahrhunderte hinweg der Standard f√ºr Dachkonstruktionen und S√§gewerke.`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/fichte_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/fichte_2.jpg?raw=true" },
             "Tanne": { info: `Tanne (TA) Tanne ist ein harzarmes, vergleichsweise feines Nadelholz, das oft als Alternative zur Fichte verwendet wird. Die Struktur √§hnelt der Fichte: feine Fasern, dezente Jahresringe, keine ausgepr√§gten Poren. Verwendung: Innenausbau, M√∂bel, Paneele, Bauholz. Funfact: Da Tanne weniger Harz enth√§lt, ist sie angenehmer in R√§umen einzusetzen, da sie weniger Geruch abgibt.`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/tanne_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/tanne_2.jpg?raw=true" },
             "L√§rche": { info: `L√§rche (LA) L√§rche ist bekannt f√ºr ihre nat√ºrliche Witterungsbest√§ndigkeit und sch√∂ne Farbe. Sie kombiniert Elastizit√§t mit Festigkeit. Das Holz zeigt ausgepr√§gte Jahresringe und Harzkan√§le ‚Äì die Struktur ist deutlich sichtbar. Verwendung: Fassadenholz, Fenster, Terrassen, Au√üenbau, M√∂bel. Funfact: L√§rchenholz wird h√§ufig ohne chemische Behandlung im Au√üenbereich eingesetzt und erh√§lt mit der Zeit eine edle Vergrauung.`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/laerche_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/laerche_2.jpg?raw=true" },
             "Birke": { info: `Birke (BI) Birke ist ein helles, dekoratives Holz mit feiner, gleichm√§√üiger Struktur. Es √ºberzeugt durch gute Biegsamkeit. Das Holz ist zerstreutporig ‚Äì Poren sind fein verteilt, ohne gro√üe Unterschiede zwischen Fr√ºh- und Sp√§tholz. Verwendung: M√∂bel, Furniere, Sperrholz, Innenausbau. Funfact: Birkenrinde wurde fr√ºher als wasserabweisendes Material f√ºr Beh√§lter und Boote genutzt.`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/birke_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/birke_2.jpg?raw=true" },
             "Ahorn": { info: `Ahorn (AM) Ahorn ist hart, hell und elegant ‚Äì ideal f√ºr feine M√∂bel, Instrumente und Designanwendungen. Es handelt sich ebenfalls um ein zerstreutporiges Holz mit gleichm√§√üiger Porenverteilung, ohne starke √úberg√§nge zwischen Fr√ºh‚Äë und Sp√§tholz. Verwendung: M√∂bel, Parkett, Instrumente, Schneidebretter. Funfact: Aus Ahorn gewinnt man auch Ahornsirup ‚Äì allerdings aus nordamerikanischen Arten, nicht unbedingt jene zum M√∂belbau.`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/ahorn_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/ahorn_2.jpg?raw=true" },
             "Esche": { info: `Esche (ES) Die Esche ist ein besonders z√§hes, elastisches Holz mit hoher Festigkeit. Sie zeigt ringporige Struktur mit deutlich sichtbaren Poren im Fr√ºhholz und schmaleren Poren im Sp√§tholz. Verwendung: Werkzeugstiele, Sportger√§te, M√∂bel, Parkett, Innenausbau. Funfact: In der Antike wurden Wagenr√§der und Speichen h√§ufig aus Esche gefertigt ‚Äì wegen ihrer elastischen Eigenschaften.`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/esche_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/esche_2.jpg?raw=true" },
             "Kirsche": { info: `Kirsche (KR) Kirschbaumholz besitzt warme rote T√∂ne, die mit Licht nachdunkeln, und eine edle Struktur. Ringporig mit deutlichem √úbergang zwischen Fr√ºh- und Sp√§tholz ‚Äì Jahresringe sind gut sichtbar. Verwendung: M√∂bel, Furniere, Innenausbau, Dekor. Funfact: Kirschholz wird oft in M√∂beln verwendet, die mit der Zeit ‚Äúreifer‚Äù aussehen ‚Äì die Farbe verbessert sich mit Alterung.`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/kirsche_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/kirsche_2.jpg?raw=true" },
             "Nussbaum": { info: `Nussbaum (NU) Nussbaumholz ist dunkel, dekorativ und sehr hochwertig. Das Kernholz hat oft starken Farbkontrast zum Splintholz. Es ist zerstreutporig ‚Äì Poren sind fein √ºber die Fl√§che verteilt, oft mit dekorativen Maserungen. Verwendung: M√∂bel, Furniere, Intarsien, edle Ausstattungen. Funfact: Walnuss (Nussbaum) war schon in der Renaissance sehr gesch√§tzt und zierte viele k√∂nigliche M√∂belst√ºcke.`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/nussbaum_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/nussbaum_2.jpg?raw=true" },
             "Douglasie": { info: `Douglasie (DO) Douglasienholz ist robust, witterungsbest√§ndig und h√§ufig im Au√üenbau eingesetzt. Die Struktur ist klar erkennbar ‚Äì deutliche Jahresringe mit Transition zwischen Fr√ºh‚Äë und Sp√§tholz. Verwendung: Bauholz, Fassaden, Dach, M√∂bel im Au√üenbereich. Funfact: Die Douglasie stammt urspr√ºnglich aus Nordamerika, ist aber auch in Europa weit verbreitet und wird gro√ügezogen.`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/douglasie_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/douglasie_2.jpg?raw=true" },
             "Zeder": { info: `Zeder (ZE) Zedernholz duftet angenehm und besitzt von Natur aus eine Resistenz gegen Insektenbefall und Feuchtigkeit. Die Struktur ist fein mit gleichm√§√üigen Poren ‚Äì kein starker Kontrast zwischen Fr√ºh- und Sp√§tholz. Verwendung: M√∂bel, Fassaden, Innenraum, Schr√§nke. Funfact: Zedernholz wird oft in Kleiderschr√§nken eingesetzt, weil es den unverwechselbaren Duft und Insektenabwehr besitzt.`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/zeder_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/zeder_2.jpg?raw=true" },
             "Mahagoni": { info: `Mahagoni (MA) Mahagoni ist ein tropisches Edelholz mit hoher Dauerhaftigkeit und edler Farbe. Es ist zerstreutporig ‚Äì Poren gleichm√§√üig verteilt und oft mit dekorativer Kernholzstruktur. Verwendung: M√∂bel, Fenster, Luxusausstattung, Bootsbau. Funfact: In manchen L√§ndern ist Mahagoni wegen seiner Seltenheit streng reguliert und unterliegt Artenschutzbestimmungen.`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/mahagoni_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/mahagoni_2.jpg?raw=true" },
             "Teak": { info: `Teak (TE) Teak ist extrem witterungsbest√§ndig durch hohen √ñl- und Harzgehalt ‚Äì ideal f√ºr Au√üenm√∂bel und Schiffsbau. Die Struktur ist fein zerstreutporig, mit dekorativem Erscheinungsbild und gleichm√§√üiger Porenverteilung. Verwendung: Gartenm√∂bel, Terrassen, Boote, Fenster, Au√üenbereich. Funfact: Teakholz war fr√ºher f√ºr den Bau von Kriegsschiffen sehr gefragt wegen seiner Dauerhaftigkeit und Wasserbest√§ndigkeit.`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/teak_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/teak_2.jpg?raw=true" },
             "Bambus": { info: `Bambus (BA) Bambus ist botanisch gesehen kein Holz, sondern ein Gras ‚Äì dennoch extrem stabil und vielseitig verwendbar. Die Struktur ist r√∂hrenartig und weist keine klassischen Poren wie Harth√∂lzer auf. Verwendung: Fu√üb√∂den, M√∂bel, Treppen, nachhaltiger Bau. Funfact: Bambus w√§chst so schnell, dass einzelne Stangen innerhalb weniger Monate √ºber einen Meter wachsen k√∂nnen.`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/bambus_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/bambus_2.jpg?raw=true" },
             "Pappel": { info: `Pappel (PA) Pappelholz ist sehr leicht und weich ‚Äì weniger tragf√§hig, aber gut bearbeitbar. Feine Struktur, fast keine gro√üen Poren ‚Äì Jahresringe nur dezent sichtbar. Verwendung: Leichtbau, Verpackungen, M√∂bel mit geringer Belastung. Funfact: Pappelholz wird oft f√ºr Modellbau oder Flugzeuginnenr√§ume verwendet, wo Leichtigkeit z√§hlt.`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/pappel_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/pappel_2.jpg?raw=true" },
             "Weide": { info: `Weide (WE) Weidenholz ist elastisch und biegsam ‚Äì traditionell f√ºr Flechtarbeiten und K√∂rbe verwendet. Die Struktur ist fein zerstreutporig, Poren kaum markant. Verwendung: Flechtwerk, Gartenbau, leichte M√∂bel. Funfact: Weidenruten werden seit Jahrhunderten f√ºr Korbgeflechte, Z√§une und Rankhilfen genutzt.`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/weide_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/weide_2.jpg?raw=true" },
             "Linde": { info: `Linde (LI) Lindenholz ist weich, homogen und gut schnitzbar ‚Äì ideal f√ºr feine Holzarbeiten. Fein zerstreutporig und gleichm√§√üig, ohne gro√üen Porenkontrast. Verwendung: Intarsien, geschnitzte Dekors, M√∂bel, Modellbau. Funfact: Lindenholz war traditionell das Holz der Bildhauer und Orgelbauer im Mittelalter.`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/linde_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/linde_2.jpg?raw=true" },
             "Ulme": { info: `Ulme (UL) Ulmenholz ist z√§h und eher hart ‚Äì fr√ºher oft f√ºr M√∂bel und Reparaturen verwendet. Ringporig mit markanten Poren und gelegentlichem unruhigem Faserverlauf. Verwendung: M√∂bel, Innenausbau, Reparaturholz. Funfact: Ulmenholz hat fr√ºher im Wagen- und M√∂belbau Bedeutung gehabt, besonders dort, wo Biegung gefragt war.`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/ulme_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/ulme_2.jpg?raw=true" },
             "Kastanie": { info: `Kastanie (KA) Kastanienholz ist √§hnlich der Eiche wetterbest√§ndig, mit warmem Farbton und markanter Struktur. Ringporig mit klar sichtbaren Jahresringen und deutlichem √úbergang. Verwendung: Au√üenbau, M√∂bel, Balken, Gartenholz. Funfact: Kastanienholz wurde oft in historischen Bauwerken als wetterbest√§ndige Alternative zur Eiche verwendet.`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/kastanie_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/kastanie_2.jpg?raw=true" },
             "Robinie": { info: `Robinie (RO) Robinienholz ist eines der h√§rtesten europ√§ischen H√∂lzer und sehr dauerhaft im Freien. Ringporig mit feinen Poren und schmalem √úbergang ‚Äì die Struktur ist weniger kontrastreich. Verwendung: Gartenholz, Terrassen, Balken, Z√§une. Funfact: Robinie wird oft als ‚Äûeurop√§isches Teak‚Äú genannt, weil es √§hnliche Eigenschaften wie Tropenholz zeigt.`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/robinie_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/robinie_2.jpg?raw=true" },
             "Hemlock": { info: `Hemlock (HE) Hemlock ist ein n√∂rdliches Nadelholz mit feiner Struktur, weich und gleichm√§√üig. Die Porenstruktur √§hnelt einfacher Zellstruktur; Jahresringe dezent sichtbar. Verwendung: Innenausbau, Paneele, Bauholz. Funfact: Hemlock wird oft im M√∂bel- und Leichtbau verwendet, wenn gutes Verh√§ltnis zwischen Gewicht und Stabilit√§t gefragt ist.`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/hemlock_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/hemlock_2.jpg?raw=true" },
             "Zypresse": { info: `Zypresse (ZY) Zypressenholz duftet gut und ist nat√ºrlich resistent gegen Feuchtigkeit und Sch√§dlinge. Die Struktur ist fein und gleichm√§√üig, mit moderatem Porencharakter. Verwendung: Au√üen- und Gartenholz, M√∂bel, Fassaden. Funfact: Zypresse wurde in mediterranen Regionen oft zur Holzverkleidung von Kirchen und Tempeln verwendet.`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/zypresse_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/zypresse_2.jpg?raw=true" },
             "Redwood": { info: `Redwood (RW) Redwood ist ein leichtes Tropenholz mit guter Dauerhaftigkeit und dekorativer Farbe. Zerstreutporig mit feiner Textur, Poren gleichm√§√üig verteilt. Verwendung: Au√üenholz, Z√§une, Gartenkonstruktionen. Funfact: Der K√ºstenmammutbaum (Redwood) z√§hlt zu den h√∂chsten B√§umen der Welt.`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/redwood_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/redwood_2.jpg?raw=true" },
             "Hickory": { info: `Hickory (HI) Hickory ist ein ausgesprochen z√§hes und hartes Holz ‚Äì ideal f√ºr stark beanspruchte Teile. Ringporig mit ausgepr√§gten Poren im Fr√ºhholz und klaren Jahresringen. Verwendung: Werkzeugstiele, Sportger√§te, M√∂bel mit hoher Belastung. Funfact: Hickory war traditionell Material f√ºr Peitschen, Wurfst√∂cke und Arbeitsger√§te.`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/hickory_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/hickory_2.jpg?raw=true" },
             "Wenge": { info: `Wenge (WE-NE) Wenge ist ein dunkles Tropenholz mit hoher H√§rte und dekorativer Maserung. Zerstreutporig mit feinen Poren ‚Äì oft Streifenzeichnung sichtbar. Verwendung: Luxusm√∂bel, Parkett, Furniere. Funfact: Wegen seiner tiefen, dunklen Farbe wird Wenge oft in Kontrasten zu hellem Holz kombiniert.`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/wenge_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/wenge_2.jpg?raw=true" },
             "Zebrano": { info: `Zebrano (ZE-RA) Zebrano zeichnet sich durch seine markante Streifenoptik aus ‚Äì dekorativ und auff√§llig. Die Porenstruktur ist zerstreutporig, oft mit deutlichem Maserungseffekt. Verwendung: Designm√∂bel, Furniere, Dekorationen. Funfact: Zebrano wird oft f√ºr luxuri√∂se Intarsien und Furnierarbeiten verwendet.`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/zebrano_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/zebrano_2.jpg?raw=true" },
             "Palisander": { info: `Palisander (PA) Palisanderholz ist dekorativ, fest und langlebig ‚Äì mit attraktiven Farbt√∂nen. Zerstreutporig mit feiner Struktur und gleichm√§√üiger Porenverteilung. Verwendung: Gitarren, M√∂bel, Furniere. Funfact: Palisanderholz war fr√ºher oft exklusiv f√ºr edle Musikinstrumente und Intarsien reserviert.`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/palisander_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/palisander_2.jpg?raw=true" },
             "Ebenholz": { info: `Ebenholz (EB) Ebenholz ist eines der h√§rtesten H√∂lzer ‚Äì fast tiefschwarz und sehr dicht. Zerstreutporig mit extrem feinen Poren, kaum sichtbar ‚Äì Porenstruktur sehr fein. Verwendung: Klaviertasten, Intarsien, Luxusdekore. Funfact: Ebenholz wurde im alten √Ñgypten f√ºr Statuetten und Schmuckst√ºcke verwendet ‚Äì wegen seiner tiefen Farbe und Seltenheit.`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/ebenholz_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/ebenholz_2.jpg?raw=true" }
        };

        const reflectionQuestions = [ /* ... (reflectionQuestions data remains unchanged) ... */
             "Stell dir vor, du sollst einen stabilen und langlebigen Esstisch f√ºr eine Familie entwerfen. ...", "Welches Holz w√ºrdest du f√ºr Gartenm√∂bel w√§hlen, ...", "Eine K√ºchenarbeitsplatte muss schnittfest und widerstandsf√§hig sein. ...", "F√ºr einen stark beanspruchten Dielenboden ...", "Du sollst den Korpus einer Akustikgitarre bauen. ...", "Fenster sind st√§ndig wechselnder Luftfeuchtigkeit ausgesetzt. ...", "F√ºr ein Modellflugzeug oder ein leichtes Regal ...", "Robinie und L√§rche sind beide f√ºr den Au√üenbereich beliebt. ...", "Du m√∂chtest einen gebogenen Handlauf ...", "Vergleiche die Rohdichte und den E-Modul von Fichte und Eiche. ...", "H√∂lzer mit hohem Quell- und Schwindma√ü ...", "Ein Hammerstiel muss extrem bruchfest ...", "Bei Eichenholz kann es in Verbindung mit Eisen ...", "Weiche H√∂lzer wie Fichte oder Kiefer ...", "F√ºr die Herstellung von dekorativen Furnieren ...", "Nenne drei heimische H√∂lzer ...", "Holz ist ein wichtiger CO‚ÇÇ-Speicher. ...", "Was bedeuten Siegel wie FSC oder PEFC ...", "Teak hat eine exzellente Dauerhaftigkeit (DK 1). ...", "Bambus ist botanisch gesehen ein Gras, ...", "Was k√∂nntest du aus einem alten Eichenbalken ...", "Du m√∂chtest ein M√∂belst√ºck mit einem starken Hell-Dunkel-Kontrast ...", "H√∂lzer wie Eiche oder Esche haben ...", "Stell dir vor, du entwirfst ein Kinderspielzeug ...", "Einige H√∂lzer wie Kirsche oder L√§rche ...", "F√ºr ein modernes, minimalistisches M√∂belst√ºck ...", "Welches Holz w√ºrdest du f√ºr den Bau einer rustikalen Almh√ºtte ...", "Du planst ein Sch√ºlerprojekt ...", "Ein Kunde w√ºnscht sich f√ºr seine Terrasse ...", "Welche Eigenschaft einer Holzart ...", "Wenn du eine neue Kategorie ...",
        ];

        const attributeInfo = { /* ... (attributeInfo data remains unchanged) ... */
            dk: {icon: 'üõ°Ô∏è', name: 'Dauerhaftigkeit (DK)', color: 'blue'},
            haerte: {icon: 'üíé', name: 'Druckfestigkeit (N/mm¬≤)', color: 'blue'},
            quellenSchwindenRadial: {icon: '‚ÜîÔ∏è', name: 'Quellen/Schwinden (%)', color: 'blue'},
            dichte: {icon: '‚öñÔ∏è', name: 'Rohdichte (kg/m¬≥)', color: 'blue'},
            gewicht: {icon: 'üèãÔ∏è', name: 'E-Modul (N/mm¬≤)', color: 'blue'}
        };

        let aiGame = { playerName: '', playerCards: [], aiCards: [], currentPlayerCard: null, currentAiCard: null, roundInProgress: false };

        // ===== Auth + Deep Link Join =====
        document.addEventListener('DOMContentLoaded', async () => {
            try { await signInAnonymously(auth); } catch (e) { console.error("Firebase Auth Error:", e); }
            onAuthStateChanged(auth, (user) => {
                if (user) {
                    localPlayerId = user.uid;
                    const urlParams = new URLSearchParams(window.location.search);
                    const gameIdFromUrl = urlParams.get('game');
                    if (gameIdFromUrl) {
                        gameId = gameIdFromUrl;
                        gameMode = 'multiplayer';
                        window.showNamePrompt('join');
                    }
                }
            });
        });

        window.addEventListener('beforeunload', async () => {
            if (gameMode === 'multiplayer' && gameId && localPlayerId) {
                const gameRef = doc(db, "games", gameId);
                const playerStatusPath = `players.${localPlayerId}.status`;
                await updateDoc(gameRef, { [playerStatusPath]: "offline" }).catch(() => {});
            }
        });

        // ===== UI Control =====
        window.showNamePrompt = (mode) => {
            document.getElementById('setupModal').classList.add('hidden');
            const nameModal = document.getElementById('nameModal');
            nameModal.classList.remove('hidden');
            const nameSubmitButton = document.getElementById('nameSubmitButton');
            // Clone and replace to remove old event listeners
            const newButton = nameSubmitButton.cloneNode(true);
            nameSubmitButton.parentNode.replaceChild(newButton, nameSubmitButton);

            newButton.addEventListener('click', () => {
                const playerName = document.getElementById('playerName').value.trim();
                if (!playerName) { alert('Bitte gib deinen Namen ein!'); return; }
                nameModal.classList.add('hidden');

                if (mode === 'ai') {
                    gameMode = 'ai';
                    startGameAI(playerName);
                } else if (mode === 'multiplayer') {
                    gameMode = 'multiplayer';
                    createGame(playerName);
                } else if (mode === 'join') {
                    joinGame(gameId, playerName);
                }
            });
        };

        window.copyShareLink = async () => {
            const linkInput = document.getElementById('shareLink');
            try {
                await navigator.clipboard.writeText(linkInput.value);
            } catch (err) {
                // Fallback for older browsers
                linkInput.select();
                document.execCommand('copy');
            }
            hasCopiedShareLink = true;
            const statusEl = document.getElementById('lobbyStatus');
            if (statusEl) statusEl.textContent = 'Link kopiert. Warte auf Mitspieler...';

            // If game already started (e.g., player 2 joined), move to game screen
            if (localGameState && (localGameState.status === 'playing' || localGameState.status === 'finished')) {
                document.getElementById('multiplayerLobbyModal').classList.add('hidden');
                document.getElementById('gameContainer').classList.remove('hidden');
                updateMultiplayerUI(localGameState);
            }
        };

        // ===== Multiplayer Logic =====
        async function createGame(playerName) {
            const lobbyModal = document.getElementById('multiplayerLobbyModal');
            lobbyModal.classList.remove('hidden');
            hasCopiedShareLink = false; // Reset copy flag

            gameId = Math.random().toString(36).substring(2, 8).toUpperCase();
            const shareLinkInput = document.getElementById('shareLink');
            const baseUrl = window.location.href.split('?')[0];
            shareLinkInput.value = `${baseUrl}?game=${gameId}`;

            const gameRef = doc(db, "games", gameId);
            const initialGameData = {
                gameId: gameId,
                status: 'waiting',
                playerIds: [localPlayerId],
                players: {
                    [localPlayerId]: { name: playerName, cards: [], status: 'online' }
                },
                createdAt: serverTimestamp()
            };

            try {
                await setDoc(gameRef, initialGameData);
                listenToGameChanges();
            } catch (error) {
                console.error("Error creating game:", error);
                alert("Fehler beim Erstellen des Spiels.");
            }
        }

        async function joinGame(gameIdToJoin, playerName) {
            const gameRef = doc(db, "games", gameIdToJoin);
            try {
                const gameSnap = await getDoc(gameRef);

                if (gameSnap.exists() && gameSnap.data().status === 'waiting' && gameSnap.data().playerIds.length === 1) {
                    document.getElementById('lobbyTitle').textContent = "Spiel wird beigetreten...";
                    document.getElementById('lobbyText').textContent = "Moment, die Karten werden gemischt.";
                    document.getElementById('multiplayerLobbyModal').classList.remove('hidden');
                    hasCopiedShareLink = true; // Joining player doesn't need to copy

                    const shuffledCards = shuffleArray([...woodCards]); // Use a copy
                    const player1Id = gameSnap.data().playerIds[0];
                    const player1Cards = shuffledCards.slice(0, 15);
                    const player2Cards = shuffledCards.slice(15, 30);

                    const gameUpdateData = {
                        status: 'playing',
                        playerIds: [player1Id, localPlayerId],
                        [`players.${localPlayerId}`]: { name: playerName, cards: player2Cards, status: 'online' },
                        [`players.${player1Id}.cards`]: player1Cards,
                        turn: player1Id, // Player 1 starts
                        currentCards: {
                            [player1Id]: player1Cards[0],
                            [localPlayerId]: player2Cards[0],
                        },
                        lastResult: null,
                        lastActivity: serverTimestamp()
                    };

                    await updateDoc(gameRef, gameUpdateData);
                    listenToGameChanges();
                } else {
                    alert("Spiel nicht gefunden, bereits voll oder beendet.");
                    window.location.search = ''; // Clear game ID from URL
                }
            } catch (error) {
                console.error("Error joining game:", error);
                alert("Fehler beim Beitreten zum Spiel.");
                window.location.search = '';
            }
        }

        function listenToGameChanges() {
            if (!gameId) return;
            const gameRef = doc(db, "games", gameId);
            unsubscribeGame = onSnapshot(gameRef, (docSnap) => {
                if (!docSnap.exists()) {
                    // Game was likely deleted
                    if(gameMode === 'multiplayer'){ // Only show alert if in multiplayer
                       alert("Das Spiel wurde beendet oder gel√∂scht.");
                       resetGame();
                    }
                    return;
                }

                const gameData = docSnap.data();
                localGameState = gameData; // Update local state

                if (gameData.status === 'playing' || gameData.status === 'finished') {
                    // Show game screen if not already visible and conditions met
                    if (hasCopiedShareLink || gameData.playerIds.includes(localPlayerId) && gameData.playerIds.length === 2) {
                        document.getElementById('multiplayerLobbyModal').classList.add('hidden');
                        document.getElementById('gameContainer').classList.remove('hidden');
                        updateMultiplayerUI(gameData);
                    } else if (!hasCopiedShareLink && gameData.playerIds.length === 2){
                         // Host hasn't clicked copy yet, but player 2 joined
                         const statusEl = document.getElementById('lobbyStatus');
                         if (statusEl) statusEl.textContent = 'Mitspieler ist beigetreten! Klicke ‚ÄûLink kopieren‚Äú, um zu starten.';
                    }
                } else if (gameData.status === 'waiting') {
                     // Still waiting, ensure lobby is shown
                     document.getElementById('multiplayerLobbyModal').classList.remove('hidden');
                     document.getElementById('gameContainer').classList.add('hidden');
                }

                // Optional: Notify if opponent goes offline (consider debounce/timing)
                const opponentId = gameData.playerIds?.find(id => id !== localPlayerId);
                if (opponentId && gameData.players[opponentId]?.status === 'offline') {
                    // Maybe show a subtle indicator instead of an alert
                    // console.log('Opponent appears offline.');
                }
            }, (error) => {
                console.error("Error listening to game changes:", error);
                // Optionally handle the error, e.g., show a message to the user
            });
        }

        function updateMultiplayerUI(gameData) {
            if (!gameData || !gameData.players || !gameData.playerIds) {
                console.error("Incomplete game data received:", gameData);
                return; // Exit if data is incomplete
            }
            const opponentId = gameData.playerIds.find(id => id !== localPlayerId);

            // Update player names and card counts
            document.getElementById('playerNameDisplay').textContent = gameData.players[localPlayerId]?.name || 'Du';
            document.getElementById('playerCards').textContent = gameData.players[localPlayerId]?.cards?.length ?? '?';

            if (opponentId && gameData.players[opponentId]) {
                document.getElementById('opponentNameDisplay').textContent = gameData.players[opponentId].name;
                document.getElementById('aiCards').textContent = gameData.players[opponentId].cards?.length ?? '?';
            } else {
                document.getElementById('opponentNameDisplay').textContent = "Wartet...";
                document.getElementById('aiCards').textContent = '-';
            }

            updateStatusBar(gameData.players[localPlayerId]?.cards?.length ?? 0, gameData.players[opponentId]?.cards?.length ?? 0);
            displayMultiplayerCards(gameData);

            const turnIndicator = document.getElementById('turnIndicator');
            const attributeSelection = document.getElementById('attributeSelection');
            const resultDisplay = document.getElementById('resultDisplay');
            const nextRoundBtn = document.getElementById('nextRoundButton');

            turnIndicator.classList.remove('hidden'); // Always show indicator area

            if (gameData.lastResult) {
                // Round finished, show result
                if (!roundSoundPlayed) {
                     roundSoundPlayed = true;
                     playSound(sounds.flip);
                     if (gameData.lastResult.winnerId === localPlayerId) {
                         playSound(sounds.win);
                     }
                 }

                attributeSelection.classList.add('hidden');
                resultDisplay.classList.remove('hidden');
                nextRoundBtn.classList.remove('hidden');

                const { winnerId, attribute, values } = gameData.lastResult;
                const opponentActualId = opponentId || 'opponent'; // Handle case where opponentId might be briefly null
                const winnerName = winnerId === localPlayerId ? 'Du' : (winnerId === 'tie' ? '' : gameData.players[winnerId]?.name || 'Gegner');

                let resultText = winnerId === 'tie' ? `ü§ù Unentschieden!` : `üéâ ${winnerName} gewinnt!`;
                if (winnerId !== localPlayerId && winnerId !== 'tie') {
                   resultText = `üòû ${winnerName} gewinnt!`;
                }
                 let resultDetailsText = `${attributeInfo[attribute]?.name.split(' (')[0] || attribute}: `;
                 resultDetailsText += `${values[localPlayerId]?.toLocaleString('de-DE') ?? '?'} vs ${values[opponentActualId]?.toLocaleString('de-DE') ?? '?'}`;


                document.getElementById('resultText').textContent = resultText;
                document.getElementById('resultDetails').textContent = resultDetailsText;

                // --- Visual Feedback ---
                const playerCardElement = document.getElementById('playerCard')?.querySelector('.card-front');
                const aiCardElement = document.getElementById('aiCard')?.querySelector('.card-front'); // Get opponent card too
                const statusBarElement = document.getElementById('statusBar');

                // Remove previous animations first
                playerCardElement?.classList.remove('animate-glow-win', 'animate-glow-lose');
                aiCardElement?.classList.remove('animate-glow-win', 'animate-glow-lose');


                if (winnerId === localPlayerId) {
                    playerCardElement?.classList.add('animate-glow-win');
                    if (statusBarElement) {
                       statusBarElement.classList.add('status-flash-win');
                       setTimeout(() => statusBarElement.classList.remove('status-flash-win'), 1200);
                    }
                    triggerWinStarAnimation();
                } else if (winnerId !== 'tie') { // Opponent won
                    playerCardElement?.classList.add('animate-glow-lose');
                    // Optionally add glow to opponent card
                    aiCardElement?.classList.add('animate-glow-win');
                     if (statusBarElement) {
                       statusBarElement.classList.add('status-flash-lose');
                       setTimeout(() => statusBarElement.classList.remove('status-flash-lose'), 1200);
                    }
                } else { // Tie
                    // Optionally add a neutral glow?
                }
                 // --- End Visual Feedback ---

            } else {
                // Round in progress, show whose turn it is
                 roundSoundPlayed = false; // Reset sound flag for the next result

                resultDisplay.classList.add('hidden');
                nextRoundBtn.classList.add('hidden');

                if (gameData.turn === localPlayerId) {
                    turnIndicator.textContent = "Du bist am Zug!";
                    turnIndicator.className = 'text-sm font-semibold p-2 text-green-600'; // Existing classes + green
                    attributeSelection.classList.remove('hidden');
                } else {
                    turnIndicator.textContent = `${gameData.players[gameData.turn]?.name || 'Gegner'} ist am Zug...`;
                    turnIndicator.className = 'text-sm font-semibold p-2 text-gray-500'; // Existing classes + gray
                    attributeSelection.classList.add('hidden');
                }
            }

            // Check for game over state
             if (gameData.status === 'finished') {
                endGame(); // Call the generic end game function
             }
        }

        function updateStatusBar(playerCount, opponentCount) {
            const total = playerCount + opponentCount;
            const playerPercentage = total > 0 ? (playerCount / total) * 100 : 50;

            const statusBar = document.getElementById('statusBar');
            if (statusBar) {
                statusBar.style.width = `${playerPercentage}%`;
                // Color coding based on percentage
                let color = '#f59e0b'; // amber-500 (Default/Near 50%)
                if (playerPercentage < 25) color = '#ef4444'; // red-500 (Losing significantly)
                else if (playerPercentage < 45) color = '#f97316'; // orange-500 (Losing)
                else if (playerPercentage > 75) color = '#22c55e'; // green-500 (Winning significantly)
                else if (playerPercentage > 55) color = '#84cc16'; // lime-500 (Winning)
                statusBar.style.backgroundColor = color;
            }
        }

        function displayMultiplayerCards(gameData) {
             if (!gameData.currentCards || !gameData.playerIds) return;

             const opponentId = gameData.playerIds.find(id => id !== localPlayerId);
             const playerCardContainer = document.getElementById('playerCard');
             const aiCardContainer = document.getElementById('aiCard');
             playerCardContainer.innerHTML = ''; // Clear previous card
             aiCardContainer.innerHTML = '';   // Clear previous card

             const showOpponentCardFace = !!gameData.lastResult; // Reveal opponent card only if result exists

             // Display player card
             if(gameData.currentCards[localPlayerId]) {
                const playerCard = createCard(gameData.currentCards[localPlayerId], true, true);
                playerCardContainer.appendChild(playerCard);
             } else {
                 playerCardContainer.innerHTML = `<div class="card-front bg-gray-200 ...">Keine Karte</div>`; // Placeholder
             }


             // Display opponent card (or placeholder)
             if (opponentId && gameData.currentCards[opponentId]) {
                 const aiCard = createCard(gameData.currentCards[opponentId], showOpponentCardFace, false);
                 aiCardContainer.appendChild(aiCard);
             } else if (gameData.playerIds.length < 2) {
                 aiCardContainer.innerHTML = `<div class="card-front bg-gray-200 rounded-xl shadow-md border-2 border-gray-300 p-3 flex flex-col items-center justify-center h-full">Wartet auf Spieler 2...</div>`;
             } else {
                 // Opponent exists, but maybe card data isn't ready yet? Show back
                  const aiCard = createCard({name: "Gegner"}, false, false); // Dummy data for back
                  aiCardContainer.appendChild(aiCard);
             }
        }


        async function multiplayerSelectAttribute(attribute) {
            if (!localGameState || localGameState.turn !== localPlayerId || localGameState.lastResult || !attributeInfo[attribute]) return;

            const playerCard = localGameState.currentCards[localPlayerId];
            const opponentId = localGameState.playerIds.find(id => id !== localPlayerId);
             if (!opponentId || !localGameState.currentCards[opponentId]) return; // Opponent not ready
            const opponentCard = localGameState.currentCards[opponentId];

            const playerValue = playerCard[attribute];
            const opponentValue = opponentCard[attribute];

            let playerWins;
            // Lower is better for 'dk' and 'quellenSchwindenRadial'
            if (attribute === 'quellenSchwindenRadial' || attribute === 'dk') {
                if (playerValue < opponentValue) playerWins = true;
                else if (opponentValue < playerValue) playerWins = false;
                else playerWins = 'tie';
            } else { // Higher is better for others
                if (playerValue > opponentValue) playerWins = true;
                else if (opponentValue > playerValue) playerWins = false;
                else playerWins = 'tie';
            }

            const winnerId = playerWins === 'tie' ? 'tie' : (playerWins ? localPlayerId : opponentId);

            const gameUpdate = {
                lastResult: {
                    winnerId,
                    attribute,
                    values: {
                        [localPlayerId]: playerValue,
                        [opponentId]: opponentValue // Use actual opponent ID
                    }
                },
                lastActivity: serverTimestamp()
                // Turn update happens in nextRound
            };

            try {
                 await updateDoc(doc(db, "games", gameId), gameUpdate);
            } catch (error) {
                 console.error("Error selecting attribute:", error);
            }
        }

        async function multiplayerNextRound() {
             // Clear visual feedback immediately
             const pf = document.getElementById('playerCard')?.querySelector('.card-front');
             if (pf) pf.classList.remove('animate-glow-win', 'animate-glow-lose');
             const af = document.getElementById('aiCard')?.querySelector('.card-front');
             if (af) af.classList.remove('animate-glow-win', 'animate-glow-lose');

            if (!localGameState || !localGameState.lastResult || !gameId) return;

             // Ensure only the designated player (winner or current player in tie) triggers the next round logic
             const { winnerId } = localGameState.lastResult;
             const isMyTurnToProceed = (winnerId === localPlayerId) || (winnerId === 'tie' && localGameState.turn === localPlayerId);

             //Allow anyone to click if needed, but only designated player performs the update
             // if (!isMyTurnToProceed) {
             //     console.log("Not your turn to trigger next round logic.");
             //     // Visually just hide buttons and wait for Firebase update
             //      document.getElementById('nextRoundButton').classList.add('hidden');
             //      document.getElementById('resultDisplay').classList.add('hidden');
             //     return;
             // }

            // Proceed with game logic update (should ideally only run once per round)
            try {
                 // --- Fetch latest state to avoid race conditions (optional but safer) ---
                 // const freshGameSnap = await getDoc(doc(db, "games", gameId));
                 // if (!freshGameSnap.exists()) return;
                 // const currentGameState = freshGameSnap.data();
                 // if (!currentGameState.lastResult) return; // Already processed by opponent?
                 // --- End fetch latest state ---

                 // Use localGameState for simplicity, assuming low chance of conflict
                const currentGameState = localGameState;
                if (!currentGameState.lastResult) return; // Prevent double execution

                const currentWinnerId = currentGameState.lastResult.winnerId;
                const [player1Id, player2Id] = currentGameState.playerIds;

                // Ensure player data is valid before proceeding
                if (!currentGameState.players[player1Id] || !currentGameState.players[player2Id]) {
                    console.error("Player data missing in game state.");
                    return;
                }


                let p1Cards = [...(currentGameState.players[player1Id].cards || [])];
                let p2Cards = [...(currentGameState.players[player2Id].cards || [])];

                // Check if cards arrays are valid
                 if (p1Cards.length === 0 && p2Cards.length === 0) {
                      console.error("Both players have no cards, cannot proceed.");
                      // Maybe declare a draw or handle error state
                      await updateDoc(doc(db, "games", gameId), { status: 'finished', lastResult: null });
                      return;
                 }


                const p1Card = p1Cards.shift(); // Take card from top
                const p2Card = p2Cards.shift(); // Take card from top

                // Only add cards if they exist (handles edge case where one deck is empty)
                if (currentWinnerId === player1Id) {
                    if (p1Card) p1Cards.push(p1Card);
                    if (p2Card) p1Cards.push(p2Card);
                } else if (currentWinnerId === player2Id) {
                    if (p1Card) p2Cards.push(p1Card);
                    if (p2Card) p2Cards.push(p2Card);
                } else { // Tie
                    if (p1Card) p1Cards.push(p1Card);
                    if (p2Card) p2Cards.push(p2Card);
                }

                // Check for game over
                if (p1Cards.length === 0 || p2Cards.length === 0) {
                    await updateDoc(doc(db, "games", gameId), {
                        status: 'finished',
                        'players': { // Update final card counts
                             [player1Id]: { ...currentGameState.players[player1Id], cards: p1Cards },
                             [player2Id]: { ...currentGameState.players[player2Id], cards: p2Cards }
                        },
                        lastResult: null // Clear result for finished state
                    });
                    // endGame() will be called by the UI update
                    return;
                }

                // Determine next turn
                const nextTurn = currentWinnerId === 'tie' ? currentGameState.turn : currentWinnerId;

                const gameUpdate = {
                    'lastResult': null, // Clear the result for the new round
                    'turn': nextTurn,
                    'players': {
                        [player1Id]: { ...currentGameState.players[player1Id], cards: p1Cards },
                        [player2Id]: { ...currentGameState.players[player2Id], cards: p2Cards }
                    },
                     // Update current cards for the next round
                    'currentCards': {
                         [player1Id]: p1Cards[0],
                         [player2Id]: p2Cards[0]
                    },
                    'lastActivity': serverTimestamp()
                };
                await updateDoc(doc(db, "games", gameId), gameUpdate);

            } catch (error) {
                console.error("Error processing next round:", error);
                 // Maybe show an error message to the user
            }
        }


        // ===== Controller for both modes =====
        window.selectAttribute = function(attribute) {
            if (gameMode === 'ai') {
                selectAttributeAI(attribute);
            } else if (gameMode === 'multiplayer') {
                multiplayerSelectAttribute(attribute);
            }
        };
        window.nextRound = function() {
            if (gameMode === 'ai') {
                nextRoundAI();
            } else if (gameMode === 'multiplayer') {
                // UI changes handled by updateMultiplayerUI, just trigger the logic
                 multiplayerNextRound();
            }
        };

        // ===== AI Mode Logic =====
        function shuffleArray(array) {
            const shuffled = [...array]; // Create a copy
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        function startGameAI(playerName) {
            aiGame.playerName = playerName;
            document.getElementById('playerNameDisplay').textContent = playerName;
            document.getElementById('opponentNameDisplay').textContent = 'Computer'; // Explicitly set opponent name
            const shuffledCards = shuffleArray(woodCards);
            aiGame.playerCards = shuffledCards.slice(0, 15);
            aiGame.aiCards = shuffledCards.slice(15, 30);
            aiGame.currentPlayerCard = aiGame.playerCards[0];
            aiGame.currentAiCard = aiGame.aiCards[0];
            aiGame.roundInProgress = false; // Ensure it's reset

             // Reset UI states explicitly
             document.getElementById('attributeSelection').classList.remove('hidden');
             document.getElementById('resultDisplay').classList.add('hidden');
             document.getElementById('nextRoundButton').classList.add('hidden');
             document.getElementById('turnIndicator').classList.add('hidden'); // Hide multiplayer indicator


            document.getElementById('gameContainer').classList.remove('hidden');
            window.scrollTo(0, 0); // Scroll to top
            updateDisplayAI();
            displayCardsAI(); // Display initial cards (player face up, AI face down)
        }

       function createCard(cardData, isRevealed = true, isPlayer = true) {
            const card = document.createElement('div');
            card.className = `card-3d w-full h-full relative ${isPlayer ? 'cursor-pointer hover-lift' : ''} transition-all duration-300`;
            if (!isRevealed) {
                card.classList.add('card-flipped');
            }

            const borderColor = isPlayer ? 'border-amber-400' : 'border-gray-300';
            const shadow = isPlayer ? 'shadow-lg' : 'shadow-md';
            const cardFront = document.createElement('div');
            // Added overflow-hidden to prevent button text wrapping issues
            cardFront.className = `card-front card-background rounded-xl ${shadow} border-2 ${borderColor} p-2 sm:p-3 flex flex-col overflow-hidden`;

            // Determine if attributes should be clickable buttons
             const canSelectAttributes = isPlayer && (
                (gameMode === 'ai' && !aiGame.roundInProgress) ||
                (gameMode === 'multiplayer' && localGameState.turn === localPlayerId && !localGameState.lastResult)
            );

             // Determine if the info button should be shown (player card, after round)
             const showInfoButton = isPlayer && (
                 (gameMode === 'ai' && aiGame.roundInProgress) ||
                 (gameMode === 'multiplayer' && !!localGameState.lastResult)
             );

             const infoButtonHTML = `
                <button id="player-info-button-${cardData.name?.replace(/\s+/g, '-') || 'unknown'}"
                        onclick="window.showWoodInfo('${cardData.name}')"
                        class="${showInfoButton ? '' : 'hidden'} bg-purple-600 text-white rounded-full h-8 w-8 sm:h-9 sm:w-9 flex items-center justify-center text-lg hover:bg-purple-700 absolute top-1 left-1 sm:top-2 sm:left-2 z-10">üí°</button>
             `;

             const woodData = woodInfo[cardData.name] || {};
             const treeImage = woodData.bildBaum || 'https://placehold.co/36x36/d1d5db/374151?text=?';

             const woodIconHTML = `
                <img src="${treeImage}" alt="${cardData.name || 'Holz'}"
                     id="wood-image-icon-${cardData.name?.replace(/\s+/g, '-') || 'unknown'}"
                     class="${showInfoButton ? 'hidden' : ''} w-8 h-8 sm:w-9 sm:w-9 object-cover rounded-full border-2 border-amber-200 flex-shrink-0 absolute top-1 left-1 sm:top-2 sm:left-2 z-10">
             `;

             // --- Attribute List/Buttons ---
            let attributeHTML = '<div class="space-y-1 mt-auto">'; // Use mt-auto to push to bottom
            for (const attrKey in attributeInfo) {
                const attr = attributeInfo[attrKey];
                const value = cardData[attrKey] ?? '?';
                const formattedValue = typeof value === 'number' ? value.toLocaleString('de-DE') : value;
                const valueUnit = attr.name.match(/\(([^)]+)\)/); // Extract unit like (DK) or (%)
                const unitText = valueUnit ? `<span class="block text-xs text-gray-500 leading-tight">${valueUnit[0]}</span>` : '';
                const nameText = attr.name.replace(/\s*\(([^)]+)\)/, ''); // Name without unit

                const commonClasses = "w-full flex justify-between items-center py-1 px-1 rounded-lg text-left border";
                const displayClasses = "bg-amber-50 border-amber-300"; // Slightly lighter for display
                const buttonClasses = "bg-amber-100 hover:bg-amber-200 border-amber-600 transition-colors";

                if (canSelectAttributes) {
                    attributeHTML += `
                        <button onclick="window.selectAttribute('${attrKey}')" class="${commonClasses} ${buttonClasses}">
                            <div class="flex items-center space-x-1 sm:space-x-2">
                               <span class="text-xs sm:text-sm">${attr.icon}</span>
                               <div>
                                   <span class="text-xs font-medium leading-tight">${nameText}</span>
                                   ${unitText}
                               </div>
                            </div>
                            <span class="font-semibold text-amber-700 text-sm sm:text-base">${formattedValue}</span>
                        </button>`;
                } else {
                    attributeHTML += `
                        <div class="${commonClasses} ${displayClasses}">
                             <div class="flex items-center space-x-1 sm:space-x-2">
                               <span class="text-xs sm:text-sm">${attr.icon}</span>
                               <div>
                                   <span class="text-xs font-medium leading-tight text-gray-700">${nameText}</span>
                                    ${unitText}
                               </div>
                            </div>
                            <span class="font-semibold text-amber-800 text-sm sm:text-base">${formattedValue}</span>
                        </div>`;
                }
            }
            attributeHTML += '</div>';
             // --- End Attribute List/Buttons ---


            cardFront.innerHTML = `
                <div class="flex justify-center items-center w-full mb-1 pt-8 sm:pt-10"> <h3 class="text-base sm:text-lg font-bold text-amber-800 truncate text-center px-1">${cardData.name || 'Unbekannt'}</h3>
                </div>
                ${isPlayer ? woodIconHTML : ''}
                ${isPlayer ? infoButtonHTML : ''}
                ${attributeHTML}
            `;

            const cardBack = document.createElement('div');
            cardBack.className = 'card-back rounded-xl shadow-lg border-2 border-amber-300 flex items-center justify-center relative overflow-hidden';

            card.appendChild(cardFront);
            card.appendChild(cardBack);
            return card;
        }


        function displayCardsAI() {
            const playerCardContainer = document.getElementById('playerCard');
            const aiCardContainer = document.getElementById('aiCard');
            playerCardContainer.innerHTML = '';
            aiCardContainer.innerHTML = '';

            if (aiGame.currentPlayerCard) {
               playerCardContainer.appendChild(createCard(aiGame.currentPlayerCard, true, true));
            }
            // Always show the AI card back unless the round is over
             if (aiGame.currentAiCard) {
                const revealAICard = aiGame.roundInProgress; // Reveal only when round is processing/over
                aiCardContainer.appendChild(createCard(aiGame.currentAiCard, revealAICard, false));
             }
        }


        function selectAttributeAI(attribute) {
            if (aiGame.roundInProgress || !aiGame.currentPlayerCard || !aiGame.currentAiCard) return;
            aiGame.roundInProgress = true;

            const playerValue = aiGame.currentPlayerCard[attribute];
            const aiValue = aiGame.currentAiCard[attribute];

            // Trigger AI card flip animation
            const aiCardElement = document.getElementById('aiCard').querySelector('.card-3d');
            if (aiCardElement) {
                aiCardElement.classList.remove('card-flipped');
                playSound(sounds.flip); // Play flip sound as card turns
            }


            // Visually disable player buttons (can be done via CSS too)
            // Re-rendering the card via displayCardsAI() handles this implicitly

            let playerWins;
            if (attribute === 'quellenSchwindenRadial' || attribute === 'dk') {
                if (playerValue < aiValue) playerWins = true; else if (aiValue < playerValue) playerWins = false; else playerWins = 'tie';
            } else {
                if (playerValue > aiValue) playerWins = true; else if (aiValue > playerValue) playerWins = false; else playerWins = 'tie';
            }

            // --- Update Game State ---
            const playerCardToMove = aiGame.playerCards.shift();
            const aiCardToMove = aiGame.aiCards.shift();

            if (playerWins === true) {
                aiGame.playerCards.push(playerCardToMove, aiCardToMove); // Winner gets both cards at the bottom
            } else if (playerWins === false) {
                aiGame.aiCards.push(aiCardToMove, playerCardToMove);
            } else { // Tie
                aiGame.playerCards.push(playerCardToMove); // Return card to bottom
                aiGame.aiCards.push(aiCardToMove);
            }
             // --- End Update Game State ---

            // --- Update UI (after a short delay for flip animation) ---
             setTimeout(() => {
                 displayCardsAI(); // Re-render cards (AI card now revealed, player card has no buttons)

                 let resultText, resultClass;
                 const playerCardFront = document.getElementById('playerCard')?.querySelector('.card-front');
                 const aiCardFront = document.getElementById('aiCard')?.querySelector('.card-front');
                 const statusBar = document.getElementById('statusBar');

                if (playerWins === true) {
                    resultText = `üéâ Du gewinnst!`;
                    resultClass = 'text-green-600';
                    playerCardFront?.classList.add('animate-glow-win');
                    if (statusBar) {
                        statusBar.classList.add('status-flash-win');
                        setTimeout(() => statusBar.classList.remove('status-flash-win'), 1200);
                    }
                    triggerWinStarAnimation();
                    playSound(sounds.win); // Play win sound
                } else if (playerWins === false) {
                    resultText = `üòû KI gewinnt!`;
                    resultClass = 'text-red-600';
                    playerCardFront?.classList.add('animate-glow-lose');
                    aiCardFront?.classList.add('animate-glow-win'); // Glow for AI win
                    if (statusBar) {
                        statusBar.classList.add('status-flash-lose');
                        setTimeout(() => statusBar.classList.remove('status-flash-lose'), 1200);
                    }
                } else {
                    resultText = `ü§ù Unentschieden!`;
                    resultClass = 'text-yellow-600';
                    // No glow for tie
                }


                // Show result text and next round button
                document.getElementById('resultText').textContent = resultText;
                document.getElementById('resultText').className = `text-xl font-bold mb-1 ${resultClass}`; // Apply color
                document.getElementById('resultDetails').textContent = `${attributeInfo[attribute].name.split(' (')[0]}: ${playerValue.toLocaleString('de-DE')} vs ${aiValue.toLocaleString('de-DE')}`;

                document.getElementById('attributeSelection').classList.add('hidden');
                document.getElementById('resultDisplay').classList.remove('hidden');
                document.getElementById('nextRoundButton').classList.remove('hidden');

                updateDisplayAI(); // Update card counts
                checkGameOverAI(); // Check if game ended
            }, 600); // Delay matches card flip duration
        }

        // highlightAttribute function is removed as re-rendering handles the visual state.

        function nextRoundAI() {
             // Clear visual feedback immediately
             const pf = document.getElementById('playerCard')?.querySelector('.card-front');
             if (pf) pf.classList.remove('animate-glow-win', 'animate-glow-lose');
             const af = document.getElementById('aiCard')?.querySelector('.card-front');
             if (af) af.classList.remove('animate-glow-win', 'animate-glow-lose');


            if (aiGame.playerCards.length === 0 || aiGame.aiCards.length === 0) {
                endGameAI(); // Game already over
                return;
            }

            // Set up next cards
            aiGame.currentPlayerCard = aiGame.playerCards[0];
            aiGame.currentAiCard = aiGame.aiCards[0];
            aiGame.roundInProgress = false;

            // Reset UI for the new round
            document.getElementById('attributeSelection').classList.remove('hidden');
            document.getElementById('nextRoundButton').classList.add('hidden');
            document.getElementById('resultDisplay').classList.add('hidden');

            displayCardsAI(); // Show new cards (AI card flipped back)
            updateDisplayAI(); // Update counts
        }

        function updateDisplayAI() {
            const playerCount = aiGame.playerCards.length;
            const opponentCount = aiGame.aiCards.length;
            document.getElementById('playerCards').textContent = playerCount;
            document.getElementById('aiCards').textContent = opponentCount;
            updateStatusBar(playerCount, opponentCount); // Use the common status bar updater
        }

        function checkGameOverAI() {
            if (!aiGame.roundInProgress) return; // Only check after a round result

            if (aiGame.playerCards.length === 0 || aiGame.aiCards.length === 0) {
                 // Delay showing game over modal slightly
                setTimeout(endGameAI, 500);
            }
        }

        function triggerWinStarAnimation() { /* ... (triggerWinStarAnimation unchanged) ... */
             const animationContainer = document.getElementById('animationContainer');
             const playerScoreBox = document.getElementById('playerScoreBox');
             const statusBar = document.getElementById('statusBar');

             if (!animationContainer || !playerScoreBox || !statusBar) return;

             const startRect = statusBar.getBoundingClientRect();
             const endRect = playerScoreBox.getBoundingClientRect();
             const containerRect = animationContainer.getBoundingClientRect();

             const star = document.createElement('div');
             star.textContent = '‚≠ê';
             star.className = 'falling-star';

             // Position star roughly center-top of the status bar portion
             star.style.left = `${startRect.left - containerRect.left + (startRect.width * (parseFloat(statusBar.style.width) / 100) / 2) - 20}px`;
             star.style.top = `${startRect.top - containerRect.top - 20}px`;

             const endY = (endRect.top + endRect.height / 2) - (startRect.top); // Target center of player score box
             star.style.setProperty('--end-y', `${endY}px`);

             animationContainer.appendChild(star);

             setTimeout(() => { star.remove(); }, 1200); // Remove after animation
        }

        function endGame() {
            // Generic end game logic, called by AI or Multiplayer mode
             if (gameMode === 'ai') {
                 endGameAI(); // Call specific AI end game if needed (already does)
             } else if (gameMode === 'multiplayer') {
                 // Multiplayer specific end logic
                 const playerWon = localGameState.players[localPlayerId]?.cards?.length > 0;
                 if (playerWon) {
                     saveToLeaderboard(localGameState.players[localPlayerId].name);
                     showReflectionOrWinScreen();
                 } else {
                     showGameOverScreen(false); // Player lost
                 }
             }
        }

        function endGameAI() {
            // Specific logic for AI game ending
            const playerWon = aiGame.playerCards.length > 0;
            if (playerWon) {
                saveToLeaderboard(aiGame.playerName);
                showReflectionOrWinScreen();
            } else {
                 showGameOverScreen(false); // Player lost
            }
        }

         function showReflectionOrWinScreen() {
             // Show reflection modal first
             let qi = parseInt(localStorage.getItem('reflectionQuestionIndex') || '0');
             document.getElementById('reflectionQuestion').textContent = reflectionQuestions[qi % reflectionQuestions.length]; // Use modulo for safety
             document.getElementById('reflectionModal').classList.remove('hidden');
             qi = (qi + 1); // Increment for next time
             localStorage.setItem('reflectionQuestionIndex', qi.toString());
         }

        window.showFinalWinScreen = function() {
            // Called after reflection is dismissed
            document.getElementById('reflectionModal').classList.add('hidden');
            document.getElementById('reflectionAnswer').value = ''; // Clear answer
            showGameOverScreen(true); // Player won
        };

         function showGameOverScreen(didPlayerWin) {
             const titleEl = document.getElementById('gameOverTitle');
             const textEl = document.getElementById('gameOverText');

             if (didPlayerWin) {
                 titleEl.textContent = 'üéâ Gl√ºckwunsch!';
                 titleEl.className = `text-3xl font-bold mb-3 text-green-600`; // Green text
                 const winnerName = (gameMode === 'ai' ? aiGame.playerName : localGameState?.players?.[localPlayerId]?.name) || 'Du';
                 textEl.textContent = `Du hast gewonnen, ${winnerName}! Du hast alle Karten gesammelt.`;
             } else {
                 titleEl.textContent = 'üòû Spiel verloren';
                 titleEl.className = `text-3xl font-bold mb-3 text-red-600`; // Red text
                 const opponentName = (gameMode === 'ai' ? 'Die KI' : localGameState?.players?.[localGameState.playerIds?.find(id => id !== localPlayerId)]?.name) || 'Dein Gegner';
                 textEl.textContent = `${opponentName} hat gewonnen. Versuche es nochmal!`;
             }
             document.getElementById('gameOverModal').classList.remove('hidden');
         }


        async function saveToLeaderboard(playerName) {
            if (!playerName) return;
            const leaderboardRef = doc(db, "leaderboard", playerName); // Use player name as doc ID
            try {
                // Use { merge: true } to create or update
                await setDoc(leaderboardRef, {
                    name: playerName,
                    wins: increment(1), // Atomically increment wins
                    lastWin: serverTimestamp()
                 }, { merge: true });
            } catch (error) {
                console.error("Error updating leaderboard:", error);
            }
        }

        window.showLeaderboard = async function() {
            const list = document.getElementById('leaderboardList');
            list.innerHTML = '<p class="text-gray-500 text-center">Lade Bestenliste...</p>';

            document.getElementById('gameOverModal').classList.add('hidden'); // Hide game over modal
            document.getElementById('leaderboardModal').classList.remove('hidden');

            try {
                const q = query(collection(db, "leaderboard"), orderBy("wins", "desc"), limit(10));
                const querySnapshot = await getDocs(q);
                if (querySnapshot.empty) {
                    list.innerHTML = '<p class="text-gray-500 text-center">Noch keine Eintr√§ge vorhanden.</p>';
                    return;
                }
                // Map results to HTML elements
                list.innerHTML = querySnapshot.docs.map((doc, index) => {
                    const data = doc.data();
                    // Basic escaping for name to prevent XSS
                    const safeName = data.name.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                    return `<div class="flex justify-between items-center p-3 ${index % 2 === 0 ? 'bg-gray-50' : 'bg-white'} rounded-lg">
                               <span class="font-semibold">${index + 1}. ${safeName}</span>
                               <span class="text-sm text-gray-600">${data.wins} Siege</span>
                            </div>`;
                }).join('');
            } catch (error) {
                console.error("Error fetching leaderboard:", error);
                list.innerHTML = '<p class="text-red-500 text-center">Fehler beim Laden der Bestenliste.</p>';
            }
        };

        window.closeLeaderboard = function() {
            document.getElementById('leaderboardModal').classList.add('hidden');
            // Show game over modal again if it was previously visible
            if (!document.getElementById('gameContainer').classList.contains('hidden')) {
               document.getElementById('gameOverModal').classList.remove('hidden');
            } else {
               document.getElementById('setupModal').classList.remove('hidden'); // Go back to setup if game wasn't running
            }
        };

        window.resetGame = async function() {
            console.log("Resetting game...");
             // Unsubscribe from Firebase listener
            if (unsubscribeGame) {
                unsubscribeGame();
                unsubscribeGame = null;
                 console.log("Unsubscribed from game changes.");
            }

            // Attempt to delete multiplayer game document if host
             // Check if I am player 1 (host) before deleting
             if (gameMode === 'multiplayer' && gameId && localGameState?.playerIds?.[0] === localPlayerId) {
                 try {
                     console.log(`Attempting to delete game ${gameId}...`);
                     await deleteDoc(doc(db, "games", gameId));
                     console.log(`Game ${gameId} deleted.`);
                 } catch (error) {
                     console.error(`Error deleting game ${gameId}:`, error);
                 }
             } else if (gameMode === 'multiplayer') {
                 console.log("Not the host or no game ID, skipping game deletion.");
             }


            // Reset local AI game state
            aiGame = { playerName: '', playerCards: [], aiCards: [], currentPlayerCard: null, currentAiCard: null, roundInProgress: false };

            // Reset global state variables
            gameMode = null;
            gameId = null;
            localGameState = {}; // Clear multiplayer state
            hasCopiedShareLink = false;
            roundSoundPlayed = false;


            // Hide all game-related modals and containers
            document.getElementById('gameOverModal').classList.add('hidden');
            document.getElementById('leaderboardModal').classList.add('hidden');
            document.getElementById('reflectionModal').classList.add('hidden');
            document.getElementById('gameContainer').classList.add('hidden');
            document.getElementById('multiplayerLobbyModal').classList.add('hidden');
             document.getElementById('nameModal').classList.add('hidden');
             document.getElementById('infoModal').classList.add('hidden');


             // Clear input fields
             document.getElementById('playerName').value = '';
             document.getElementById('reflectionAnswer').value = '';
             document.getElementById('shareLink').value = '';
             document.getElementById('lobbyStatus').textContent = '';

             // Show the initial setup modal
            document.getElementById('setupModal').classList.remove('hidden');


            // Clean up URL (remove ?game=...)
            window.history.pushState({}, document.title, window.location.pathname);
            console.log("Game reset complete.");
        };


        window.showWoodInfo = function(woodName) {
            const modal = document.getElementById('infoModal');
            const titleEl = document.getElementById('infoModalTitle');
            const contentEl = document.getElementById('infoModalContent');

            titleEl.textContent = `Wissenswertes √ºber ${woodName}`;
            const infoData = woodInfo[woodName] || null; // Find info case-insensitively later if needed

            if (infoData) {
                // Basic HTML structure for info and images
                contentEl.innerHTML = `
                    <p class="text-left">${infoData.info || 'Keine Beschreibung verf√ºgbar.'}</p>
                    <div class="space-y-4 mt-4">
                        <div>
                            <h4 class="font-semibold mb-2 text-center">Baum</h4>
                            <img src="${infoData.bildBaum || ''}" alt="Bild von ${woodName} Baum" class="w-full max-h-60 h-auto rounded-lg object-contain mx-auto" onerror="this.style.display='none'; this.previousElementSibling.style.display='none';">
                        </div>
                        <div>
                            <h4 class="font-semibold mb-2 text-center">Querschnitt</h4>
                            <img src="${infoData.bildQuerschnitt || ''}" alt="Bild von ${woodName} Querschnitt" class="w-full max-h-60 h-auto rounded-lg object-contain mx-auto" onerror="this.style.display='none'; this.previousElementSibling.style.display='none';">
                        </div>
                    </div>`;
            } else {
                contentEl.innerHTML = "<p>F√ºr diese Holzart sind aktuell keine Detailinformationen verf√ºgbar.</p>";
            }
            modal.classList.remove('hidden');
        };

        window.closeInfoModal = function() {
            document.getElementById('infoModal').classList.add('hidden');
        };

    </script>
</body>
</html>
