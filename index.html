<script type="module">
    // ===== Firebase Imports =====
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
    import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, serverTimestamp, deleteDoc, collection, query, orderBy, limit, getDocs, increment } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

    // ===== Firebase Config =====
    const firebaseConfig = {
        apiKey: "AIzaSyCyRXl8-JPr1xTXPDi1VG-eQk6fOnTpqUI",
        authDomain: "holzquartett-3a177.firebaseapp.com",
        projectId: "holzquartett-3a177",
        storageBucket: "holzquartett-3a177.appspot.com",
        messagingSenderId: "1081595025073",
        appId: "1:1081595025073:web:bc571fffb6e4f20b27f490",
        measurementId: "G-HKLWFJE83K"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);
    const appId = firebaseConfig.projectId;

    // ===== Global State =====
    let gameMode = null;
    let gameId = null;
    let localPlayerId = null;
    let unsubscribeGame = null;
    let localGameState = {};
    let hasCopiedShareLink = false;
    let isMuted = false;
    let roundSoundPlayed = false; // Verhindert doppeltes Abspielen im MP

    // ===== Sound Effects (NEU) =====
    const sounds = {
        flip: new Audio('https://github.com/aufdemholzweg/holzquartett/raw/refs/heads/main/Sounds/cardflip.mp3'),
        turnWin: new Audio('https://github.com/aufdemholzweg/holzquartett/raw/refs/heads/main/Sounds/spielzuggewonnen.wav'),
        gameWin: new Audio('https://github.com/aufdemholzweg/holzquartett/raw/refs/heads/main/Sounds/spielgewonnen.mp3'),
        chime: new Audio('https://cdn.pixabay.com/audio/2021/08/04/audio_12b0c744c8.mp3') // F√ºr Stern-Animation
    };
    
    // Lautst√§rke auf "mittel" (0.5) setzen
    sounds.flip.volume = 0.5;
    sounds.turnWin.volume = 0.5;
    sounds.gameWin.volume = 0.5;
    sounds.chime.volume = 0.5; // (Auch der Chime)

    // ===== playSound function =====
    function playSound(sound) {
        if (isMuted) return; 
        sound.currentTime = 0;
        sound.play().catch(e => console.log("Sound playback error:", e));
    }

    // ===== Wood Data =====
    const woodCards = [ /* ... alle Kartendaten ... */ 
        {name: "Eiche", dk: 2, haerte: 85, quellenSchwindenRadial: 4.0, dichte: 650, gewicht: 12000}, {name: "Buche", dk: 5, haerte: 80, quellenSchwindenRadial: 5.8, dichte: 720, gewicht: 14000}, {name: "Kiefer", dk: 3, haerte: 40, quellenSchwindenRadial: 3.5, dichte: 520, gewicht: 11000}, {name: "Fichte", dk: 4, haerte: 35, quellenSchwindenRadial: 3.6, dichte: 450, gewicht: 11000}, {name: "Tanne", dk: 4, haerte: 38, quellenSchwindenRadial: 3.5, dichte: 460, gewicht: 10000}, {name: "L√§rche", dk: 3, haerte: 55, quellenSchwindenRadial: 3.7, dichte: 590, gewicht: 12000}, {name: "Birke", dk: 5, haerte: 60, quellenSchwindenRadial: 5.4, dichte: 650, gewicht: 13000}, {name: "Ahorn", dk: 5, haerte: 75, quellenSchwindenRadial: 4.8, dichte: 630, gewicht: 12500}, {name: "Esche", dk: 5, haerte: 90, quellenSchwindenRadial: 4.9, dichte: 700, gewicht: 13000}, {name: "Kirsche", dk: 3, haerte: 70, quellenSchwindenRadial: 4.0, dichte: 600, gewicht: 11500}, {name: "Nussbaum", dk: 3, haerte: 65, quellenSchwindenRadial: 4.0, dichte: 640, gewicht: 12000}, {name: "Douglasie", dk: 3, haerte: 45, quellenSchwindenRadial: 3.5, dichte: 510, gewicht: 12000}, {name: "Zeder", dk: 2, haerte: 42, quellenSchwindenRadial: 2.8, dichte: 480, gewicht: 9500}, {name: "Mahagoni", dk: 2, haerte: 55, quellenSchwindenRadial: 3.0, dichte: 550, gewicht: 10500}, {name: "Teak", dk: 1, haerte: 60, quellenSchwindenRadial: 2.5, dichte: 650, gewicht: 11000}, {name: "Bambus", dk: 4, haerte: 50, quellenSchwindenRadial: 3.0, dichte: 400, gewicht: 18000}, {name: "Pappel", dk: 5, haerte: 25, quellenSchwindenRadial: 4.5, dichte: 380, gewicht: 9000}, {name: "Weide", dk: 5, haerte: 30, quellenSchwindenRadial: 4.0, dichte: 420, gewicht: 8000}, {name: "Linde", dk: 5, haerte: 35, quellenSchwindenRadial: 3.8, dichte: 530, gewicht: 9000}, {name: "Ulme", dk: 3, haerte: 75, quellenSchwindenRadial: 4.5, dichte: 680, gewicht: 11500}, {name: "Kastanie", dk: 2, haerte: 50, quellenSchwindenRadial: 3.5, dichte: 600, gewicht: 10000}, {name: "Robinie", dk: 1, haerte: 80, quellenSchwindenRadial: 3.0, dichte: 730, gewicht: 15000}, {name: "Hemlock", dk: 4, haerte: 40, quellenSchwindenRadial: 3.6, dichte: 500, gewicht: 10000}, {name: "Zypresse", dk: 2, haerte: 48, quellenSchwindenRadial: 3.0, dichte: 520, gewicht: 9000}, {name: "Redwood", dk: 2, haerte: 35, quellenSchwindenRadial: 2.8, dichte: 400, gewicht: 8500}, {name: "Hickory", dk: 3, haerte: 95, quellenSchwindenRadial: 5.5, dichte: 750, gewicht: 14000}, {name: "Wenge", dk: 2, haerte: 88, quellenSchwindenRadial: 3.8, dichte: 880, gewicht: 16000}, {name: "Zebrano", dk: 3, haerte: 70, quellenSchwindenRadial: 4.0, dichte: 750, gewicht: 13000}, {name: "Palisander", dk: 2, haerte: 82, quellenSchwindenRadial: 3.0, dichte: 850, gewicht: 16000}, {name: "Ebenholz", dk: 1, haerte: 98, quellenSchwindenRadial: 3.2, dichte: 1200, gewicht: 16500}
    ];
    const woodInfo = { /* ... alle Holzinformationen ... */ 
         "Eiche": { info: `Eiche (QE) Die Eiche z√§hlt zu den bedeutendsten heimischen Laubh√∂lzern Europas. ...`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/eiche_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/eiche_2.jpg?raw=true" },
         "Buche": { info: `Buche (BU) Die Buche ist ein gleichm√§√üig strukturiertes Hartholz...`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/buche_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/buche_2.jpg?raw=true" },
         "Kiefer": { info: `Kiefer (KI) Kiefer ist ein weit verbreitetes Nadelholz...`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/kiefer_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/kiefer_2.jpg?raw=true" },
         "Fichte": { info: `Fichte (FI) Fichte ist ein klassisches Bauholz...`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/fichte_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/fichte_2.jpg?raw=true" },
         "Tanne": { info: `Tanne (TA) Tanne ist ein harzarmes, vergleichsweise feines Nadelholz...`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/tanne_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/tanne_2.jpg?raw=true" },
         "L√§rche": { info: `L√§rche (LA) L√§rche ist bekannt f√ºr ihre nat√ºrliche Witterungsbest√§ndigkeit...`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/laerche_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/laerche_2.jpg?raw=true" },
         "Birke": { info: `Birke (BI) Birke ist ein helles, dekoratives Holz...`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/birke_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/birke_2.jpg?raw=true" },
         "Ahorn": { info: `Ahorn (AM) Ahorn ist hart, hell und elegant...`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/ahorn_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/ahorn_2.jpg?raw=true" },
         "Esche": { info: `Esche (ES) Die Esche ist ein besonders z√§hes, elastisches Holz...`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/esche_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/esche_2.jpg?raw=true" },
         "Kirsche": { info: `Kirsche (KR) Kirschbaumholz besitzt warme rote T√∂ne...`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/kirsche_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/kirsche_2.jpg?raw=true" },
         "Nussbaum": { info: `Nussbaum (NU) Nussbaumholz ist dunkel, dekorativ...`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/nussbaum_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/nussbaum_2.jpg?raw=true" },
         "Douglasie": { info: `Douglasie (DO) Douglasienholz ist robust, witterungsbest√§ndig...`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/douglasie_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/douglasie_2.jpg?raw=true" },
         "Zeder": { info: `Zeder (ZE) Zedernholz duftet angenehm...`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/zeder_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/zeder_2.jpg?raw=true" },
         "Mahagoni": { info: `Mahagoni (MA) Mahagoni ist ein tropisches Edelholz...`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/mahagoni_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/mahagoni_2.jpg?raw=true" },
         "Teak": { info: `Teak (TE) Teak ist extrem witterungsbest√§ndig...`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/teak_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/teak_2.jpg?raw=true" },
         "Bambus": { info: `Bambus (BA) Bambus ist botanisch gesehen kein Holz...`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/bambus_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/bambus_2.jpg?raw=true" },
         "Pappel": { info: `Pappel (PA) Pappelholz ist sehr leicht und weich...`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/pappel_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/pappel_2.jpg?raw=true" },
         "Weide": { info: `Weide (WE) Weidenholz ist elastisch und biegsam...`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/weide_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/weide_2.jpg?raw=true" },
         "Linde": { info: `Linde (LI) Lindenholz ist weich, homogen...`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/linde_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/linde_2.jpg?raw=true" },
         "Ulme": { info: `Ulme (UL) Ulmenholz ist z√§h und eher hart...`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/ulme_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/ulme_2.jpg?raw=true" },
         "Kastanie": { info: `Kastanie (KA) Kastanienholz ist √§hnlich der Eiche...`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/kastanie_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/kastanie_2.jpg?raw=true" },
         "Robinie": { info: `Robinie (RO) Robinienholz ist eines der h√§rtesten...`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/robinie_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/robinie_2.jpg?raw=true" },
         "Hemlock": { info: `Hemlock (HE) Hemlock ist ein n√∂rdliches Nadelholz...`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/hemlock_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/hemlock_2.jpg?raw=true" },
         "Zypresse": { info: `Zypresse (ZY) Zypressenholz duftet gut...`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/zypresse_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/zypresse_2.jpg?raw=true" },
         "Redwood": { info: `Redwood (RW) Redwood ist ein leichtes Tropenholz...`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/redwood_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/redwood_2.jpg?raw=true" },
         "Hickory": { info: `Hickory (HI) Hickory ist ein ausgesprochen z√§hes...`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/hickory_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/hickory_2.jpg?raw=true" },
         "Wenge": { info: `Wenge (WE-NE) Wenge ist ein dunkles Tropenholz...`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/wenge_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/wenge_2.jpg?raw=true" },
         "Zebrano": { info: `Zebrano (ZE-RA) Zebrano zeichnet sich durch seine markante...`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/zebrano_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/zebrano_2.jpg?raw=true" },
         "Palisander": { info: `Palisander (PA) Palisanderholz ist dekorativ, fest...`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/palisander_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/palisander_2.jpg?raw=true" },
         "Ebenholz": { info: `Ebenholz (EB) Ebenholz ist eines der h√§rtesten...`, bildBaum: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/ebenholz_1.jpg?raw=true", bildQuerschnitt: "https://github.com/aufdemholzweg/holzquartett/blob/main/images/ebenholz_2.jpg?raw=true" }
    };
    const reflectionQuestions = [ /* ... alle Reflexionsfragen ... */ 
         "Stell dir vor, du sollst einen stabilen und langlebigen Esstisch f√ºr eine Familie entwerfen. ...", "Welches Holz w√ºrdest du f√ºr Gartenm√∂bel w√§hlen, ...", "Eine K√ºchenarbeitsplatte muss schnittfest und widerstandsf√§hig sein. ...", "F√ºr einen stark beanspruchten Dielenboden ...", "Du sollst den Korpus einer Akustikgitarre bauen. ...", "Fenster sind st√§ndig wechselnder Luftfeuchtigkeit ausgesetzt. ...", "F√ºr ein Modellflugzeug oder ein leichtes Regal ...", "Robinie und L√§rche sind beide f√ºr den Au√üenbereich beliebt. ...", "Du m√∂chtest einen gebogenen Handlauf ...", "Vergleiche die Rohdichte und den E-Modul von Fichte und Eiche. ...", "H√∂lzer mit hohem Quell- und Schwindma√ü ...", "Ein Hammerstiel muss extrem bruchfest ...", "Bei Eichenholz kann es in Verbindung mit Eisen ...", "Weiche H√∂lzer wie Fichte oder Kiefer ...", "F√ºr die Herstellung von dekorativen Furnieren ...", "Nenne drei heimische H√∂lzer ...", "Holz ist ein wichtiger CO‚ÇÇ-Speicher. ...", "Was bedeuten Siegel wie FSC oder PEFC ...", "Teak hat eine exzellente Dauerhaftigkeit (DK 1). ...", "Bambus ist botanisch gesehen ein Gras, ...", "Was k√∂nntest du aus einem alten Eichenbalken ...", "Du m√∂chtest ein M√∂belst√ºck mit einem starken Hell-Dunkel-Kontrast ...", "H√∂lzer wie Eiche oder Esche haben ...", "Stell dir vor, du entwirfst ein Kinderspielzeug ...", "Einige H√∂lzer wie Kirsche oder L√§rche ...", "F√ºr ein modernes, minimalistisches M√∂belst√ºck ...", "Welches Holz w√ºrdest du f√ºr den Bau einer rustikalen Almh√ºtte ...", "Du planst ein Sch√ºlerprojekt ...", "Ein Kunde w√ºnscht sich f√ºr seine Terrasse ...", "Welche Eigenschaft einer Holzart ...", "Wenn du eine neue Kategorie ...",
    ];
    const attributeInfo = { /* ... alle Attribut-Infos ... */ 
        dk: {icon: 'üõ°Ô∏è', name: 'Dauerhaftigkeit (DK)', color: 'blue'},
        haerte: {icon: 'üíé', name: 'Druckfestigkeit (N/mm¬≤)', color: 'blue'},
        quellenSchwindenRadial: {icon: '‚ÜîÔ∏è', name: 'Quellen/Schwinden (%)', color: 'blue'},
        dichte: {icon: '‚öñÔ∏è', name: 'Rohdichte (kg/m¬≥)', color: 'blue'},
        gewicht: {icon: 'üèãÔ∏è', name: 'E-Modul (N/mm¬≤)', color: 'blue'}
    };

    // --- aiGame state ---
    let aiGame = { playerName: '', playerCards: [], aiCards: [], currentPlayerCard: null, currentAiCard: null, roundInProgress: false, turn: 'player' };

    // ===== Auth + Deep Link Join =====
    document.addEventListener('DOMContentLoaded', async () => { /* ... DOMContentLoaded listener ... */
        try { await signInAnonymously(auth); } catch (e) { console.error("Firebase Auth Error:", e); }
        onAuthStateChanged(auth, (user) => {
            if (user) {
                localPlayerId = user.uid;
                const urlParams = new URLSearchParams(window.location.search);
                const gameIdFromUrl = urlParams.get('game');
                if (gameIdFromUrl) {
                    gameId = gameIdFromUrl;
                    gameMode = 'multiplayer';
                    window.showNamePrompt('join');
                }
            }
        });
       });
    window.addEventListener('beforeunload', async () => { /* ... beforeunload listener ... */
         if (gameMode === 'multiplayer' && gameId && localPlayerId) {
            const gameRef = doc(db, "games", gameId);
            const playerStatusPath = `players.${localPlayerId}.status`;
            await updateDoc(gameRef, { [playerStatusPath]: "offline" }).catch(() => {});
        }
    });

    // ===== UI Control =====
    window.showNamePrompt = (mode) => { /* ... showNamePrompt function ... */
         document.getElementById('setupModal').classList.add('hidden');
        const nameModal = document.getElementById('nameModal');
        nameModal.classList.remove('hidden');
        const nameSubmitButton = document.getElementById('nameSubmitButton');
        const newButton = nameSubmitButton.cloneNode(true);
        nameSubmitButton.parentNode.replaceChild(newButton, nameSubmitButton);
        newButton.addEventListener('click', () => {
            const playerName = document.getElementById('playerName').value.trim();
            if (!playerName) { alert('Bitte gib deinen Namen ein!'); return; }
            nameModal.classList.add('hidden');
            if (mode === 'ai') { gameMode = 'ai'; startGameAI(playerName); }
            else if (mode === 'multiplayer') { gameMode = 'multiplayer'; createGame(playerName); }
            else if (mode === 'join') { joinGame(gameId, playerName); }
        });
    };
    window.copyShareLink = async () => { /* ... copyShareLink function ... */
         const linkInput = document.getElementById('shareLink');
        try { await navigator.clipboard.writeText(linkInput.value); }
        catch (err) { linkInput.select(); document.execCommand('copy'); }
        hasCopiedShareLink = true;
        const statusEl = document.getElementById('lobbyStatus');
        if (statusEl) statusEl.textContent = 'Link kopiert. Warte auf Mitspieler...';
        if (localGameState && (localGameState.status === 'playing' || localGameState.status === 'finished')) {
            document.getElementById('multiplayerLobbyModal').classList.add('hidden');
            document.getElementById('gameContainer').classList.remove('hidden');
            updateMultiplayerUI(localGameState);
        }
    };

    // ===== Multiplayer Logic =====
    async function createGame(playerName) { /* ... createGame function ... */
        const lobbyModal = document.getElementById('multiplayerLobbyModal');
        lobbyModal.classList.remove('hidden');
        hasCopiedShareLink = false;
        gameId = Math.random().toString(36).substring(2, 8).toUpperCase();
        const shareLinkInput = document.getElementById('shareLink');
        const baseUrl = window.location.href.split('?')[0];
        shareLinkInput.value = `${baseUrl}?game=${gameId}`;

        // QR-Code generieren
        const qrContainer = document.getElementById('qrCodeContainer');
        qrContainer.innerHTML = '';
        try {
            if (!window.QRCode || !QRCode.toCanvas) {
                console.error('QRCode-Bibliothek nicht geladen oder toCanvas nicht verf√ºgbar.');
            } else {
                const canvas = document.createElement('canvas');
                QRCode.toCanvas(
                    canvas,
                    shareLinkInput.value,
                    {
                        width: 180,
                        margin: 1,
                        color: {
                            dark: '#854d0e',
                            light: '#ffffff'
                        }
                    },
                    function (err) {
                        if (err) {
                            console.error("QR Code generation failed:", err);
                            return;
                        }
                        canvas.style.borderRadius = '0.5rem'; // rounded-lg
                        canvas.style.border = '1px solid #f59e0b'; // border-amber-500
                        qrContainer.appendChild(canvas);
                    }
                );
            }
        } catch (err) {
            console.error("Fehler beim Generieren des QR-Codes:", err);
        }

        const gameRef = doc(db, "games", gameId);
        const initialGameData = { gameId: gameId, status: 'waiting', playerIds: [localPlayerId], players: { [localPlayerId]: { name: playerName, cards: [], status: 'online' } }, createdAt: serverTimestamp() };
        try { await setDoc(gameRef, initialGameData); listenToGameChanges(); }
        catch (error) { console.error("Error creating game:", error); alert("Fehler beim Erstellen des Spiels."); }
    }
    async function joinGame(gameIdToJoin, playerName) { /* ... joinGame function ... */
        const gameRef = doc(db, "games", gameIdToJoin);
        try {
            const gameSnap = await getDoc(gameRef);
            if (gameSnap.exists() && gameSnap.data().status === 'waiting' && gameSnap.data().playerIds.length === 1) {
                document.getElementById('lobbyTitle').textContent = "Spiel wird beigetreten...";
                document.getElementById('lobbyText').textContent = "Moment, die Karten werden gemischt.";
                document.getElementById('multiplayerLobbyModal').classList.remove('hidden');
                hasCopiedShareLink = true;
                const shuffledCards = shuffleArray([...woodCards]);
                const player1Id = gameSnap.data().playerIds[0];
                const player1Cards = shuffledCards.slice(0, 15);
                const player2Cards = shuffledCards.slice(15, 30);
                const gameUpdateData = { status: 'playing', playerIds: [player1Id, localPlayerId], [`players.${localPlayerId}`]: { name: playerName, cards: player2Cards, status: 'online' }, [`players.${player1Id}.cards`]: player1Cards, turn: player1Id, currentCards: { [player1Id]: player1Cards[0], [localPlayerId]: player2Cards[0] }, lastResult: null, lastActivity: serverTimestamp() };
                await updateDoc(gameRef, gameUpdateData);
                listenToGameChanges();
            } else { alert("Spiel nicht gefunden, bereits voll oder beendet."); window.location.search = ''; }
        } catch (error) { console.error("Error joining game:", error); alert("Fehler beim Beitreten zum Spiel."); window.location.search = ''; }
    }
    function listenToGameChanges() { /* ... listenToGameChanges function ... */
         if (!gameId) return;
        const gameRef = doc(db, "games", gameId);
        unsubscribeGame = onSnapshot(gameRef, (docSnap) => {
            if (!docSnap.exists()) { if(gameMode === 'multiplayer'){ alert("Das Spiel wurde beendet oder gel√∂scht."); resetGame(); } return; }
            const gameData = docSnap.data();
            localGameState = gameData;
            if (gameData.status === 'playing' || gameData.status === 'finished') {
                if (hasCopiedShareLink || gameData.playerIds.includes(localPlayerId) && gameData.playerIds.length === 2) { document.getElementById('multiplayerLobbyModal').classList.add('hidden'); document.getElementById('gameContainer').classList.remove('hidden'); updateMultiplayerUI(gameData); }
                else if (!hasCopiedShareLink && gameData.playerIds.length === 2){ const statusEl = document.getElementById('lobbyStatus'); if (statusEl) statusEl.textContent = 'Mitspieler ist beigetreten! Klicke ‚ÄûLink kopieren‚Äú, um zu starten.'; }
            } else if (gameData.status === 'waiting') { document.getElementById('multiplayerLobbyModal').classList.remove('hidden'); document.getElementById('gameContainer').classList.add('hidden'); }
            const opponentId = gameData.playerIds?.find(id => id !== localPlayerId);
            if (opponentId && gameData.players[opponentId]?.status === 'offline') { /* console.log('Opponent appears offline.'); */ }
        }, (error) => { console.error("Error listening to game changes:", error); });
    }
    
    // --- updateMultiplayerUI (KORRIGIERT: sounds.win -> sounds.turnWin) ---
    function updateMultiplayerUI(gameData) { 
        if (!gameData || !gameData.players || !gameData.playerIds) { console.error("Incomplete game data received:", gameData); return; }
        const opponentId = gameData.playerIds.find(id => id !== localPlayerId);
        document.getElementById('playerNameDisplay').textContent = gameData.players[localPlayerId]?.name || 'Du';
        document.getElementById('playerCards').textContent = gameData.players[localPlayerId]?.cards?.length ?? '?';
        if (opponentId && gameData.players[opponentId]) { document.getElementById('opponentNameDisplay').textContent = gameData.players[opponentId].name; document.getElementById('aiCards').textContent = gameData.players[opponentId].cards?.length ?? '?'; }
        else { document.getElementById('opponentNameDisplay').textContent = "Wartet..."; document.getElementById('aiCards').textContent = '-'; }
        updateStatusBar(gameData.players[localPlayerId]?.cards?.length ?? 0, gameData.players[opponentId]?.cards?.length ?? 0);
        displayMultiplayerCards(gameData);
        const turnIndicator = document.getElementById('turnIndicator');
        const attributeSelection = document.getElementById('attributeSelection');
        const resultDisplay = document.getElementById('resultDisplay');
        const nextRoundBtn = document.getElementById('nextRoundButton');
        turnIndicator.classList.remove('hidden');
        if (gameData.lastResult) {
            if (!roundSoundPlayed) { 
                roundSoundPlayed = true; 
                playSound(sounds.flip); 
                if (gameData.lastResult.winnerId === localPlayerId) { 
                    playSound(sounds.turnWin); // KORRIGIERT (war sounds.win)
                } 
            }
            attributeSelection.classList.add('hidden');
            resultDisplay.classList.remove('hidden');
            nextRoundBtn.classList.remove('hidden');
            const { winnerId, attribute, values } = gameData.lastResult;
            const opponentActualId = opponentId || 'opponent';
            const winnerName = winnerId === localPlayerId ? 'Du' : (winnerId === 'tie' ? '' : gameData.players[winnerId]?.name || 'Gegner');
            let resultText = winnerId === 'tie' ? `ü§ù Unentschieden!` : `üéâ ${winnerName} gewinnt!`;
            if (winnerId !== localPlayerId && winnerId !== 'tie') { resultText = `üòû ${winnerName} gewinnt!`; }
            let resultDetailsText = `${attributeInfo[attribute]?.name.split(' (')[0] || attribute}: ${values[localPlayerId]?.toLocaleString('de-DE') ?? '?'} vs ${values[opponentActualId]?.toLocaleString('de-DE') ?? '?'}`;
            document.getElementById('resultText').textContent = resultText;
            document.getElementById('resultDetails').textContent = resultDetailsText;
            const attributeIndex = Object.keys(attributeInfo).indexOf(attribute);
            if (attributeIndex !== -1) {
                const playerRow = document.querySelector(`#playerCard .space-y-1 > *:nth-child(${attributeIndex + 1})`);
                const opponentRow = document.querySelector(`#aiCard .space-y-1 > *:nth-child(${attributeIndex + 1})`);
                const highlightClass = 'bg-yellow-200';
                const playerCurrentBg = playerRow?.classList.toString().match(/bg-(amber|gray|yellow)-[0-9]+/)?.[0];
                const opponentCurrentBg = opponentRow?.classList.toString().match(/bg-(amber|gray|yellow)-[0-9]+/)?.[0];
                if (playerRow) { if (playerCurrentBg) playerRow.classList.remove(playerCurrentBg); playerRow.classList.add(highlightClass); }
                if (opponentRow) { if (opponentCurrentBg) opponentRow.classList.remove(opponentCurrentBg); opponentRow.classList.add(highlightClass); }
            }
            const playerCardElement = document.getElementById('playerCard')?.querySelector('.card-front');
            const aiCardElement = document.getElementById('aiCard')?.querySelector('.card-front');
            const statusBarElement = document.getElementById('statusBar');
            playerCardElement?.classList.remove('animate-glow-win', 'animate-glow-lose');
            aiCardElement?.classList.remove('animate-glow-win', 'animate-glow-lose');
            if (winnerId === localPlayerId) { playerCardElement?.classList.add('animate-glow-win'); if (statusBarElement) { /* status bar flash win */ } triggerWinStarAnimation(); }
            else if (winnerId !== 'tie') { playerCardElement?.classList.add('animate-glow-lose'); aiCardElement?.classList.add('animate-glow-win'); if (statusBarElement) { /* status bar flash lose */ } }
            window.scrollTo({ top: 0, behavior: 'smooth' }); // <<< SCROLL MULTIPLAYER
        } else {
             roundSoundPlayed = false;
            resultDisplay.classList.add('hidden');
            nextRoundBtn.classList.add('hidden');
            if (gameData.turn === localPlayerId) { turnIndicator.textContent = "Du bist am Zug!"; turnIndicator.className = 'text-sm font-semibold p-1 text-green-600'; attributeSelection.classList.remove('hidden'); } // MODIFIED p-1
            else { turnIndicator.textContent = `${gameData.players[gameData.turn]?.name || 'Gegner'} ist am Zug...`; turnIndicator.className = 'text-sm font-semibold p-1 text-gray-500'; attributeSelection.classList.add('hidden'); } // MODIFIED p-1
        }
         if (gameData.status === 'finished') { endGame(); }
    }
    
    function updateStatusBar(playerCount, opponentCount) { /* ... updateStatusBar unchanged ... */
         const total = playerCount + opponentCount; const playerPercentage = total > 0 ? (playerCount / total) * 100 : 50; const statusBar = document.getElementById('statusBar'); if (statusBar) { statusBar.style.width = `${playerPercentage}%`; let color = '#f59e0b'; if (playerPercentage < 25) color = '#ef4444'; else if (playerPercentage < 45) color = '#f97316'; else if (playerPercentage > 75) color = '#22c55e'; else if (playerPercentage > 55) color = '#84cc16'; statusBar.style.backgroundColor = color; }
    }
    function displayMultiplayerCards(gameData) { /* ... displayMultiplayerCards unchanged ... */
        if (!gameData.currentCards || !gameData.playerIds) return; const opponentId = gameData.playerIds.find(id => id !== localPlayerId); const playerCardContainer = document.getElementById('playerCard'); const aiCardContainer = document.getElementById('aiCard'); playerCardContainer.innerHTML = ''; aiCardContainer.innerHTML = ''; const showOpponentCardFace = !!gameData.lastResult; if(gameData.currentCards[localPlayerId]) { const playerCard = createCard(gameData.currentCards[localPlayerId], true, true); playerCardContainer.appendChild(playerCard); } else { playerCardContainer.innerHTML = `<div class="card-front bg-gray-200 ...">Warte auf Karte...</div>`; } if (opponentId && gameData.currentCards[opponentId]) { const aiCard = createCard(gameData.currentCards[opponentId], showOpponentCardFace, false); aiCardContainer.appendChild(aiCard); } else if (gameData.playerIds.length < 2) { aiCardContainer.innerHTML = `<div class="card-front bg-gray-200 ...">Wartet auf Spieler 2...</div>`; } else { const dummyOpponentCardData = { name: "Gegner", dk: '?', haerte: '?', quellenSchwindenRadial: '?', dichte: '?', gewicht: '?' }; const aiCard = createCard(dummyOpponentCardData, false, false); aiCardContainer.appendChild(aiCard); }
    }
    async function multiplayerSelectAttribute(attribute) { /* ... multiplayerSelectAttribute unchanged ... */
         if (!localGameState || localGameState.turn !== localPlayerId || localGameState.lastResult || !attributeInfo[attribute]) return; const playerCard = localGameState.currentCards?.[localPlayerId]; const opponentId = localGameState.playerIds?.find(id => id !== localPlayerId); if (!opponentId || !localGameState.currentCards?.[opponentId]) { console.warn("Opponent or opponent card not ready."); return; } const opponentCard = localGameState.currentCards[opponentId]; const playerValue = playerCard?.[attribute]; const opponentValue = opponentCard?.[attribute]; if (playerValue === undefined || opponentValue === undefined) { console.error("Attribute value missing for comparison:", attribute); return; } let playerWins; if (attribute === 'quellenSchwindenRadial' || attribute === 'dk') { if (playerValue < opponentValue) playerWins = true; else if (opponentValue < playerValue) playerWins = false; else playerWins = 'tie'; } else { if (playerValue > opponentValue) playerWins = true; else if (opponentValue > playerValue) playerWins = false; else playerWins = 'tie'; } const winnerId = playerWins === 'tie' ? 'tie' : (playerWins ? localPlayerId : opponentId); const gameUpdate = { lastResult: { winnerId, attribute, values: { [localPlayerId]: playerValue, [opponentId]: opponentValue } }, lastActivity: serverTimestamp() }; try { await updateDoc(doc(db, "games", gameId), gameUpdate); } catch (error) { console.error("Error selecting attribute:", error); }
    }
    async function multiplayerNextRound() { /* ... multiplayerNextRound unchanged ... */
        const pf = document.getElementById('playerCard')?.querySelector('.card-front'); if (pf) pf.classList.remove('animate-glow-win', 'animate-glow-lose'); const af = document.getElementById('aiCard')?.querySelector('.card-front'); if (af) af.classList.remove('animate-glow-win', 'animate-glow-lose'); document.querySelectorAll('#playerCard .space-y-1 > *, #aiCard .space-y-1 > *').forEach(el => { el.classList.remove('bg-yellow-200', 'bg-gray-300'); }); if (!localGameState || !localGameState.lastResult || !gameId) { console.log("Next round conditions not met."); return; } try { const currentGameState = localGameState; if (!currentGameState.lastResult) { console.log("Result already processed, likely by other player."); return; } const currentWinnerId = currentGameState.lastResult.winnerId; const [player1Id, player2Id] = currentGameState.playerIds; if (!currentGameState.players?.[player1Id]?.cards || !currentGameState.players?.[player2Id]?.cards) { console.error("Player card data missing in game state for next round."); return; } let p1Cards = [...currentGameState.players[player1Id].cards]; let p2Cards = [...currentGameState.players[player2Id].cards]; if (p1Cards.length === 0 && p2Cards.length === 0 && currentGameState.status !== 'finished') { console.error("Both players have no cards, but game not finished. Setting to finished."); await updateDoc(doc(db, "games", gameId), { status: 'finished', lastResult: null }); return; } const p1Card = p1Cards.shift(); const p2Card = p2Cards.shift(); if (currentWinnerId === player1Id) { if (p1Card) p1Cards.push(p1Card); if (p2Card) p1Cards.push(p2Card); } else if (currentWinnerId === player2Id) { if (p1Card) p2Cards.push(p1Card); if (p2Card) p2Cards.push(p2Card); } else { if (p1Card) p1Cards.push(p1Card); if (p2Card) p2Cards.push(p2Card); } if (p1Cards.length === 0 || p2Cards.length === 0) { console.log("Game over condition met."); await updateDoc(doc(db, "games", gameId), { status: 'finished', 'players': { [player1Id]: { ...currentGameState.players[player1Id], cards: p1Cards }, [player2Id]: { ...currentGameState.players[player2Id], cards: p2Cards } }, currentCards: { [player1Id]: null, [player2Id]: null }, lastResult: null }); return; } const nextTurn = currentWinnerId === 'tie' ? currentGameState.turn : currentWinnerId; const gameUpdate = { 'lastResult': null, 'turn': nextTurn, 'players': { [player1Id]: { ...currentGameState.players[player1Id], cards: p1Cards }, [player2Id]: { ...currentGameState.players[player2Id], cards: p2Cards } }, 'currentCards': { [player1Id]: p1Cards[0] || null, [player2Id]: p2Cards[0] || null }, 'lastActivity': serverTimestamp() }; console.log("Updating Firebase for next round:", gameUpdate); await updateDoc(doc(db, "games", gameId), gameUpdate); } catch (error) { console.error("Error processing multiplayer next round:", error); }
    }


    // ===== Controller for both modes =====
    window.selectAttribute = function(attribute) { /* ... selectAttribute controller ... */
        if (gameMode === 'ai') { selectAttributeAI(attribute); }
        else if (gameMode === 'multiplayer') { multiplayerSelectAttribute(attribute); }
    };
    window.nextRound = function() { /* ... nextRound controller ... */
         if (gameMode === 'ai') { nextRoundAI(); }
         else if (gameMode === 'multiplayer') { multiplayerNextRound(); }
    };

    // ===== AI Mode Logic =====
    function shuffleArray(array) { /* ... shuffleArray function ... */
         const shuffled = [...array]; for (let i = shuffled.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]]; } return shuffled;
    }

    // --- Modified startGameAI (Added turn init) ---
    function startGameAI(playerName) {
        aiGame.playerName = playerName;
        document.getElementById('playerNameDisplay').textContent = playerName;
        document.getElementById('opponentNameDisplay').textContent = 'Computer';
        const shuffledCards = shuffleArray(woodCards);
        aiGame.playerCards = shuffledCards.slice(0, 15);
        aiGame.aiCards = shuffledCards.slice(15, 30);
        aiGame.currentPlayerCard = aiGame.playerCards[0];
        aiGame.currentAiCard = aiGame.aiCards[0];
        aiGame.roundInProgress = false;
        aiGame.turn = 'player'; // Player starts

        // Reset UI states
        document.getElementById('attributeSelection').classList.remove('hidden'); // Show selection initially
        document.getElementById('resultDisplay').classList.add('hidden');
        document.getElementById('nextRoundButton').classList.add('hidden');
        document.getElementById('turnIndicator').classList.remove('hidden'); // Show indicator area


        document.getElementById('gameContainer').classList.remove('hidden');
        window.scrollTo(0, 0);
        updateDisplayAI(); // Update card counts and turn indicator
        displayCardsAI();
    }

   // --- Modified createCard (checks aiGame.turn, updated header layout, shortened label) ---
    function createCard(cardData, isRevealed = true, isPlayer = true) {
        const card = document.createElement('div');
        card.className = `card-3d w-full h-full relative ${isPlayer ? 'cursor-pointer hover-lift' : ''} transition-all duration-300`;
        if (!isRevealed) { card.classList.add('card-flipped'); }
        const borderColor = isPlayer ? 'border-amber-400' : 'border-gray-300';
        const shadow = isPlayer ? 'shadow-lg' : 'shadow-md';
        const cardFront = document.createElement('div');
        cardFront.className = `card-front card-background rounded-xl ${shadow} border-2 ${borderColor} p-2 sm:p-3 flex flex-col overflow-hidden`;
        const canSelectAttributes = isPlayer && ((gameMode === 'ai' && !aiGame.roundInProgress && aiGame.turn === 'player') || (gameMode === 'multiplayer' && localGameState?.turn === localPlayerId && !localGameState?.lastResult));
        const showInfoButton = isPlayer && ((gameMode === 'ai' && aiGame.roundInProgress) || (gameMode === 'multiplayer' && !!localGameState?.lastResult));
        const cardName = cardData?.name || 'Unbekannt';
        const safeCardNameId = cardName.replace(/[^a-zA-Z0-9]/g, '-') || 'unknown';
        let headerRightContent = '';
        if (isPlayer) {
             const woodData = woodInfo[cardName] || {};
             const treeImage = woodData.bildBaum || 'https://placehold.co/36x36/d1d5db/374151?text=?';
             headerRightContent = `<div class="flex-shrink-0 relative w-8 h-8 sm:w-9 sm:w-9"><img src="${treeImage}" alt="${cardName}" id="wood-image-icon-${safeCardNameId}" class="${showInfoButton ? 'hidden' : ''} absolute inset-0 w-full h-full object-cover rounded-full border-2 border-amber-200"><button id="player-info-button-${safeCardNameId}" onclick="window.showWoodInfo('${cardName.replace(/'/g, "\\'")}')" class="${showInfoButton ? '' : 'hidden'} absolute inset-0 bg-purple-600 text-white rounded-full flex items-center justify-center text-lg hover:bg-purple-700 z-10">üí°</button></div>`;
          }
        let attributeHTML = '<div class="space-y-1 mt-auto">';
        for (const attrKey in attributeInfo) {
            if (Object.hasOwnProperty.call(attributeInfo, attrKey)) {
                const attr = attributeInfo[attrKey]; const value = cardData?.[attrKey] ?? '?'; const formattedValue = typeof value === 'number' ? value.toLocaleString('de-DE') : value; const valueUnit = attr.name.match(/\(([^)]+)\)/); const unitText = valueUnit ? `<span class="block text-[10px] sm:text-xs text-gray-500 leading-tight">${valueUnit[0]}</span>` : ''; const nameText = attr.name.replace(/\s*\(([^)]+)\)/, '');
                // <<< MODIFIED: Shortened label for quellenSchwindenRadial >>><
                const displayName = (attrKey === 'quellenSchwindenRadial') ? 'Quellen/Schw.' : nameText;
                const baseBgClass = canSelectAttributes ? 'bg-amber-100' : 'bg-amber-50'; const hoverBgClass = canSelectAttributes ? 'hover:bg-amber-200' : ''; const borderClass = canSelectAttributes ? 'border-amber-600' : 'border-amber-300'; const textClass = canSelectAttributes ? 'text-amber-700' : 'text-amber-800'; const commonClasses = `w-full flex justify-between items-center py-0.5 sm:py-1 px-1 rounded-lg text-left border ${borderClass} ${baseBgClass}`; const interactiveClasses = `${hoverBgClass} transition-colors`;
                if (canSelectAttributes) { attributeHTML += `<button onclick="window.selectAttribute('${attrKey}')" class="${commonClasses} ${interactiveClasses}"><div class="flex items-center space-x-1 sm:space-x-2"><span class="text-xs sm:text-sm">${attr.icon}</span><div><span class="text-[11px] sm:text-xs font-medium leading-tight">${displayName}</span>${unitText}</div></div><span class="font-semibold ${textClass} text-sm sm:text-base">${formattedValue}</span></button>`; } // Used displayName
                else { attributeHTML += `<div class="${commonClasses}"><div class="flex items-center space-x-1 sm:space-x-2"><span class="text-xs sm:text-sm">${attr.icon}</span><div><span class="text-[11px] sm:text-xs font-medium leading-tight text-gray-700">${displayName}</span>${unitText}</div></div><span class="font-semibold ${textClass} text-sm sm:text-base">${formattedValue}</span></div>`; } // Used displayName
            }
        } attributeHTML += '</div>';
        cardFront.innerHTML = `<div class="flex justify-between items-center w-full mb-2 px-1 h-9 sm:h-10"><h3 class="text-base sm:text-lg font-bold text-amber-800 truncate text-left mr-2">${cardName}</h3>${headerRightContent}</div>${attributeHTML}`;
        const cardBack = document.createElement('div'); cardBack.className = 'card-back rounded-xl shadow-lg border-2 border-amber-300 flex items-center justify-center relative overflow-hidden';
        card.appendChild(cardFront); card.appendChild(cardBack); return card;
    }


    function displayCardsAI() { /* ... displayCardsAI unchanged ... */
        const playerCardContainer = document.getElementById('playerCard'); const aiCardContainer = document.getElementById('aiCard'); playerCardContainer.innerHTML = ''; aiCardContainer.innerHTML = ''; if (aiGame.currentPlayerCard) { playerCardContainer.appendChild(createCard(aiGame.currentPlayerCard, true, true)); } else { playerCardContainer.innerHTML = `<div class="card-front bg-gray-200 ...">Keine Karte</div>`; } if (aiGame.currentAiCard) { const revealAICard = aiGame.roundInProgress; aiCardContainer.appendChild(createCard(aiGame.currentAiCard, revealAICard, false)); } else { aiCardContainer.innerHTML = `<div class="card-front bg-gray-200 ...">Keine Karte</div>`; }
    }

    // --- Modified selectAttributeAI (checks turn, sets next turn, SCROLL ADDED) ---
    function selectAttributeAI(attribute) {
        if (aiGame.roundInProgress || aiGame.turn !== 'player' || !aiGame.currentPlayerCard || !aiGame.currentAiCard || !attributeInfo[attribute]) return;
        aiGame.roundInProgress = true;
        const playerValue = aiGame.currentPlayerCard[attribute];
        const aiValue = aiGame.currentAiCard[attribute];
        if (playerValue === undefined || aiValue === undefined) { console.error("AI Mode: Attribute value missing for comparison:", attribute); aiGame.roundInProgress = false; return; }
        const aiCardElement = document.getElementById('aiCard').querySelector('.card-3d');
        if (aiCardElement) { aiCardElement.classList.remove('card-flipped'); playSound(sounds.flip); }
        let playerWins;
        if (attribute === 'quellenSchwindenRadial' || attribute === 'dk') { if (playerValue < aiValue) playerWins = true; else if (aiValue < playerValue) playerWins = false; else playerWins = 'tie'; }
        else { if (playerValue > aiValue) playerWins = true; else if (aiValue < playerValue) playerWins = false; else playerWins = 'tie'; }
        const playerCardToMove = aiGame.playerCards.shift(); const aiCardToMove = aiGame.aiCards.shift(); let winnerTurn = aiGame.turn;
        if (playerWins === true) { if (playerCardToMove) aiGame.playerCards.push(playerCardToMove); if (aiCardToMove) aiGame.playerCards.push(aiCardToMove); winnerTurn = 'player'; }
        else if (playerWins === false) { if (aiCardToMove) aiGame.aiCards.push(aiCardToMove); if (playerCardToMove) aiGame.aiCards.push(playerCardToMove); winnerTurn = 'ai'; }
        else { if (playerCardToMove) aiGame.playerCards.push(playerCardToMove); if (aiCardToMove) aiGame.aiCards.push(aiCardToMove); }
        aiGame.turn = winnerTurn;
        setTimeout(() => {
             displayCardsAI();
             let resultText, resultClass; const playerCardFront = document.getElementById('playerCard')?.querySelector('.card-front'); const aiCardFront = document.getElementById('aiCard')?.querySelector('.card-front'); const statusBar = document.getElementById('statusBar');
            const attributeIndex = Object.keys(attributeInfo).indexOf(attribute);
             if (attributeIndex !== -1) { const playerRow = playerCardFront?.querySelector(`.space-y-1 > *:nth-child(${attributeIndex + 1})`); const opponentRow = aiCardFront?.querySelector(`.space-y-1 > *:nth-child(${attributeIndex + 1})`); const highlightClass = 'bg-yellow-200'; const playerCurrentBg = playerRow?.classList.toString().match(/bg-(amber|gray|yellow)-[0-9]+/)?.[0]; const opponentCurrentBg = opponentRow?.classList.toString().match(/bg-(amber|gray|yellow)-[0-9]+/)?.[0]; if (playerRow) { if (playerCurrentBg) playerRow.classList.remove(playerCurrentBg); playerRow.classList.add(highlightClass); } if (opponentRow) { if (opponentCurrentBg) opponentRow.classList.remove(opponentCurrentBg); opponentRow.classList.add(highlightClass); } }
            if (playerWins === true) { resultText = `üéâ Du gewinnst!`; resultClass = 'text-green-600'; playerCardFront?.classList.add('animate-glow-win'); if (statusBar) { statusBar.classList.add('status-flash-win'); setTimeout(() => statusBar.classList.remove('status-flash-win'), 1200); } triggerWinStarAnimation(); }
            else if (playerWins === false) { resultText = `üòû KI gewinnt!`; resultClass = 'text-red-600'; playerCardFront?.classList.add('animate-glow-lose'); aiCardFront?.classList.add('animate-glow-win'); if (statusBar) { statusBar.classList.add('status-flash-lose'); setTimeout(() => statusBar.classList.remove('status-flash-lose'), 1200); } }
            else { resultText = `ü§ù Unentschieden!`; resultClass = 'text-yellow-600'; }
            document.getElementById('resultText').textContent = resultText; document.getElementById('resultText').className = `text-lg sm:text-xl font-bold ${resultClass}`; document.getElementById('resultDetails').textContent = `${attributeInfo[attribute].name.split(' (')[0]}: ${playerValue.toLocaleString('de-DE')} vs ${aiValue.toLocaleString('de-DE')}`; document.getElementById('attributeSelection').classList.add('hidden'); document.getElementById('resultDisplay').classList.remove('hidden'); document.getElementById('nextRoundButton').classList.remove('hidden');
            updateDisplayAI(); checkGameOverAI();
            window.scrollTo({ top: 0, behavior: 'smooth' }); // <<< SCROLL AI PLAYER
        }, 600);
    }

    // --- NEUE Funktion: aiSelectAttribute (SCROLL ADDED) ---
    function aiSelectAttribute() {
        if (aiGame.roundInProgress || aiGame.turn !== 'ai' || !aiGame.currentPlayerCard || !aiGame.currentAiCard) return;
        aiGame.roundInProgress = true;
        setTimeout(() => {
            const availableAttributes = Object.keys(attributeInfo); const randomIndex = Math.floor(Math.random() * availableAttributes.length); const chosenAttribute = availableAttributes[randomIndex]; console.log(`AI chose: ${chosenAttribute}`);
            const playerValue = aiGame.currentPlayerCard[chosenAttribute]; const aiValue = aiGame.currentAiCard[chosenAttribute];
            if (playerValue === undefined || aiValue === undefined) { console.error("AI Mode (AI Turn): Attribute value missing for comparison:", chosenAttribute); aiGame.roundInProgress = false; nextRoundAI(); return; }
            let playerWins; if (chosenAttribute === 'quellenSchwindenRadial' || chosenAttribute === 'dk') { if (playerValue < aiValue) playerWins = true; else if (aiValue < playerValue) playerWins = false; else playerWins = 'tie'; } else { if (playerValue > aiValue) playerWins = true; else if (aiValue < playerValue) playerWins = false; else playerWins = 'tie'; }
            const playerCardToMove = aiGame.playerCards.shift(); const aiCardToMove = aiGame.aiCards.shift(); let winnerTurn = aiGame.turn;
            if (playerWins === true) { if (playerCardToMove) aiGame.playerCards.push(playerCardToMove); if (aiCardToMove) aiGame.playerCards.push(aiCardToMove); winnerTurn = 'player'; }
            else if (playerWins === false) { if (aiCardToMove) aiGame.aiCards.push(aiCardToMove); if (playerCardToMove) aiGame.aiCards.push(playerCardToMove); winnerTurn = 'ai'; }
            else { if (playerCardToMove) aiGame.playerCards.push(playerCardToMove); if (aiCardToMove) aiGame.aiCards.push(aiCardToMove); }
            aiGame.turn = winnerTurn;
            displayCardsAI();
            let resultText, resultClass; const playerCardFront = document.getElementById('playerCard')?.querySelector('.card-front'); const aiCardFront = document.getElementById('aiCard')?.querySelector('.card-front'); const statusBar = document.getElementById('statusBar');
            const attributeIndex = Object.keys(attributeInfo).indexOf(chosenAttribute);
             if (attributeIndex !== -1) { const playerRow = playerCardFront?.querySelector(`.space-y-1 > *:nth-child(${attributeIndex + 1})`); const opponentRow = aiCardFront?.querySelector(`.space-y-1 > *:nth-child(${attributeIndex + 1})`); const highlightClass = 'bg-yellow-200'; const playerCurrentBg = playerRow?.classList.toString().match(/bg-(amber|gray|yellow)-[0-9]+/)?.[0]; const opponentCurrentBg = opponentRow?.classList.toString().match(/bg-(amber|gray|yellow)-[0-9]+/)?.[0]; if (playerRow) { if (playerCurrentBg) playerRow.classList.remove(playerCurrentBg); playerRow.classList.add(highlightClass); } if (opponentRow) { if (opponentCurrentBg) opponentRow.classList.remove(opponentCurrentBg); opponentRow.classList.add(highlightClass); } }
             if (playerWins === true) { resultText = `üéâ Du gewinnst!`; resultClass = 'text-green-600'; playerCardFront?.classList.add('animate-glow-win'); aiCardFront?.classList.add('animate-glow-lose'); if (statusBar) { statusBar.classList.add('status-flash-win'); setTimeout(() => statusBar.classList.remove('status-flash-win'), 1200); } triggerWinStarAnimation(); }
             else if (playerWins === false) { resultText = `üòû KI gewinnt!`; resultClass = 'text-red-600'; playerCardFront?.classList.add('animate-glow-lose'); aiCardFront?.classList.add('animate-glow-win'); if (statusBar) { statusBar.classList.add('status-flash-lose'); setTimeout(() => statusBar.classList.remove('status-flash-lose'), 1200); } }
             else { resultText = `ü§ù Unentschieden!`; resultClass = 'text-yellow-600'; }
            document.getElementById('resultText').textContent = resultText; document.getElementById('resultText').className = `text-lg sm:text-xl font-bold ${resultClass}`; document.getElementById('resultDetails').textContent = `${attributeInfo[chosenAttribute].name.split(' (')[0]}: ${playerValue.toLocaleString('de-DE')} vs ${aiValue.toLocaleString('de-DE')}`; document.getElementById('attributeSelection').classList.add('hidden'); document.getElementById('resultDisplay').classList.remove('hidden'); document.getElementById('nextRoundButton').classList.remove('hidden');
            updateDisplayAI(); checkGameOverAI();
            window.scrollTo({ top: 0, behavior: 'smooth' }); // <<< SCROLL AI TURN
        }, 1500);
    }

    // --- Modified nextRoundAI (checks turn, calls aiSelectAttribute) ---
    function nextRoundAI() {
         const pf = document.getElementById('playerCard')?.querySelector('.card-front'); if (pf) pf.classList.remove('animate-glow-win', 'animate-glow-lose'); const af = document.getElementById('aiCard')?.querySelector('.card-front'); if (af) af.classList.remove('animate-glow-win', 'animate-glow-lose'); document.querySelectorAll('#playerCard .space-y-1 > *, #aiCard .space-y-1 > *').forEach(el => { el.classList.remove('bg-yellow-200', 'bg-gray-300'); });
        if (aiGame.playerCards.length === 0 || aiGame.aiCards.length === 0) { if(!document.getElementById('gameOverModal').classList.contains('hidden')) { document.getElementById('nextRoundButton').classList.add('hidden'); document.getElementById('resultDisplay').classList.add('hidden'); } else { endGameAI(); } return; }
        aiGame.currentPlayerCard = aiGame.playerCards[0]; aiGame.currentAiCard = aiGame.aiCards[0]; aiGame.roundInProgress = false;
        document.getElementById('nextRoundButton').classList.add('hidden'); document.getElementById('resultDisplay').classList.add('hidden');
        updateDisplayAI(); // Update counts and turn indicator first
        displayCardsAI(); // Show new cards
        if (aiGame.turn === 'ai') { document.getElementById('attributeSelection').classList.add('hidden'); aiSelectAttribute(); } // AI's turn
        else { document.getElementById('attributeSelection').classList.remove('hidden'); } // Player's turn
    }

    // --- Modified updateDisplayAI (adds turn indicator logic) ---
    function updateDisplayAI() {
        const playerCount = aiGame.playerCards.length; const opponentCount = aiGame.aiCards.length; document.getElementById('playerCards').textContent = playerCount; document.getElementById('aiCards').textContent = opponentCount; updateStatusBar(playerCount, opponentCount);
        const turnIndicator = document.getElementById('turnIndicator'); turnIndicator.classList.remove('hidden');
        if(aiGame.roundInProgress) { if (!document.getElementById('resultDisplay').classList.contains('hidden')) { turnIndicator.textContent = ''; } else if (aiGame.turn === 'ai') { turnIndicator.textContent = `Computer √ºberlegt...`; turnIndicator.className = 'text-sm font-semibold p-1 text-gray-500'; } else { turnIndicator.textContent = ''; } } // MODIFIED p-1
        else if (aiGame.turn === 'player') { turnIndicator.textContent = "Du bist am Zug!"; turnIndicator.className = 'text-sm font-semibold p-1 text-green-600'; } // MODIFIED p-1
        else { turnIndicator.textContent = `Computer ist am Zug...`; turnIndicator.className = 'text-sm font-semibold p-1 text-gray-500'; } // MODIFIED p-1
    }


    function checkGameOverAI() { /* ... checkGameOverAI unchanged ... */
         if (aiGame.roundInProgress) { if (aiGame.playerCards.length === 0 || aiGame.aiCards.length === 0) { setTimeout(endGameAI, 300); } }
    }

    // --- Modified triggerWinStarAnimation (KORRIGIERT: sounds.starWin -> sounds.turnWin) ---
    function triggerWinStarAnimation() {
         const animationContainer = document.getElementById('animationContainer');
         const playerScoreBox = document.getElementById('playerScoreBox');
         const statusBar = document.getElementById('statusBar');
         if (!animationContainer || !playerScoreBox || !statusBar) return;
         const startRect = statusBar.getBoundingClientRect();
         const endRect = playerScoreBox.getBoundingClientRect();
         const containerRect = animationContainer.getBoundingClientRect();
         const star = document.createElement('div');
         star.textContent = '‚≠ê';
         star.className = 'falling-star';
         const playerBarWidth = startRect.width * (parseFloat(statusBar.style.width) / 100);
         star.style.left = `${startRect.left - containerRect.left + (playerBarWidth / 2) - 20}px`;
         star.style.top = `${startRect.top - containerRect.top - 20}px`;
         const endY = (endRect.top + endRect.height / 2) - (startRect.top);
         star.style.setProperty('--end-y', `${endY}px`);
         animationContainer.appendChild(star);
         playSound(sounds.chime); // Play original chime
         playSound(sounds.turnWin); // <<< PLAY turnWin SOUND
         setTimeout(() => { star.remove(); }, 1200);
    }

    // --- endGame (KORRIGIERT: Spiel-Sieg-Sound hinzugef√ºgt) ---
    function endGame() { 
         console.log(`Game ended. Mode: ${gameMode}`); 
         if (gameMode === 'ai') { 
             if (!document.getElementById('gameOverModal').classList.contains('hidden') || !document.getElementById('reflectionModal').classList.contains('hidden')){ /* Modal already shown */ } 
             else { endGameAI(); } 
         } else if (gameMode === 'multiplayer') { 
             const finalPlayerCards = localGameState?.players?.[localPlayerId]?.cards?.length ?? 0; 
             const opponentId = localGameState?.playerIds?.find(id => id !== localPlayerId); 
             const finalOpponentCards = localGameState?.players?.[opponentId]?.cards?.length ?? 0; 
             const playerWon = finalPlayerCards > finalOpponentCards; 
             const isDraw = finalPlayerCards === 0 && finalOpponentCards === 0; 
             if (isDraw) { 
                 showGameOverScreen(null); 
             } else if (playerWon) { 
                 playSound(sounds.gameWin); // <<< SPIEL GEWONNEN SOUND (MP)
                 saveToLeaderboard(localGameState.players[localPlayerId].name); 
                 showReflectionOrWinScreen(); 
             } else { 
                 showGameOverScreen(false); 
             } 
         } else { 
             console.warn("endGame called without a valid gameMode set."); 
         }
    }
    
    // --- endGameAI (KORRIGIERT: Spiel-Sieg-Sound hinzugef√ºgt) ---
    function endGameAI() { 
        if (!document.getElementById('gameOverModal').classList.contains('hidden') || !document.getElementById('reflectionModal').classList.contains('hidden')) return; 
        console.log("Calling endGameAI"); 
        const playerWon = aiGame.playerCards.length > 0; 
        if (playerWon) { 
            playSound(sounds.gameWin); // <<< SPIEL GEWONNEN SOUND (AI)
            saveToLeaderboard(aiGame.playerName); 
            showReflectionOrWinScreen(); 
        } else { 
            showGameOverScreen(false); 
        }
    }
    
     function showReflectionOrWinScreen() { /* ... showReflectionOrWinScreen unchanged ... */
         let qi = parseInt(localStorage.getItem('reflectionQuestionIndex') || '0'); document.getElementById('reflectionQuestion').textContent = reflectionQuestions[qi % reflectionQuestions.length]; document.getElementById('reflectionModal').classList.remove('hidden'); qi = (qi + 1); localStorage.setItem('reflectionQuestionIndex', qi.toString());
     }
    window.showFinalWinScreen = function() { /* ... showFinalWinScreen unchanged ... */
         document.getElementById('reflectionModal').classList.add('hidden'); document.getElementById('reflectionAnswer').value = ''; showGameOverScreen(true);
    };
     function showGameOverScreen(didPlayerWin) { /* ... showGameOverScreen unchanged ... */
         document.getElementById('reflectionModal').classList.add('hidden'); document.getElementById('leaderboardModal').classList.add('hidden'); const titleEl = document.getElementById('gameOverTitle'); const textEl = document.getElementById('gameOverText'); const modalEl = document.getElementById('gameOverModal'); if (didPlayerWin === true) { titleEl.textContent = 'üéâ Gl√ºckwunsch!'; titleEl.className = `text-3xl font-bold mb-3 text-green-600`; const winnerName = (gameMode === 'ai' ? aiGame.playerName : localGameState?.players?.[localPlayerId]?.name) || 'Du'; textEl.textContent = `Du hast gewonnen, ${winnerName}! Du hast alle Karten gesammelt.`; } else if (didPlayerWin === false) { titleEl.textContent = 'üòû Spiel verloren'; titleEl.className = `text-3xl font-bold mb-3 text-red-600`; const opponentName = (gameMode === 'ai' ? 'Die KI' : localGameState?.players?.[localGameState.playerIds?.find(id => id !== localPlayerId)]?.name) || 'Dein Gegner'; textEl.textContent = `${opponentName} hat gewonnen. Versuche es nochmal!`; } else { titleEl.textContent = 'ü§ù Unentschieden!'; titleEl.className = `text-3xl font-bold mb-3 text-yellow-600`; textEl.textContent = `Das Spiel endet unentschieden!`; } modalEl.classList.remove('hidden');
     }
    async function saveToLeaderboard(playerName) { /* ... saveToLeaderboard unchanged ... */
        if (!playerName) return; const safePlayerName = playerName.replace(/[.#$[\]]/g, '_'); const leaderboardRef = doc(db, "leaderboard", safePlayerName); try { await setDoc(leaderboardRef, { name: playerName, wins: increment(1), lastWin: serverTimestamp() }, { merge: true }); console.log(`Leaderboard updated for ${playerName}`); } catch (error) { console.error("Error updating leaderboard:", error); }
    }
    window.showLeaderboard = async function() { /* ... showLeaderboard unchanged ... */
         const list = document.getElementById('leaderboardList'); list.innerHTML = '<p class="text-gray-500 text-center">Lade Bestenliste...</p>'; document.getElementById('gameOverModal').classList.add('hidden'); document.getElementById('leaderboardModal').classList.remove('hidden'); try { const q = query(collection(db, "leaderboard"), orderBy("wins", "desc"), limit(10)); const querySnapshot = await getDocs(q); if (querySnapshot.empty) { list.innerHTML = '<p class="text-gray-500 text-center">Noch keine Eintr√§ge vorhanden.</p>'; return; } list.innerHTML = querySnapshot.docs.map((doc, index) => { const data = doc.data(); const safeName = (data.name || 'Unbekannt').replace(/</g, "&lt;").replace(/>/g, "&gt;"); return `<div class="flex justify-between items-center p-3 ${index % 2 === 0 ? 'bg-gray-50' : 'bg-white'} rounded-lg"><span class="font-semibold">${index + 1}. ${safeName}</span><span class="text-sm text-gray-600">${data.wins || 0} Siege</span></div>`; }).join(''); } catch (error) { console.error("Error fetching leaderboard:", error); list.innerHTML = '<p class="text-red-500 text-center">Fehler beim Laden der Bestenliste.</p>'; }
    };
    window.closeLeaderboard = function() { /* ... closeLeaderboard unchanged ... */
         document.getElementById('leaderboardModal').classList.add('hidden'); if (localGameState?.status === 'finished' || (gameMode === 'ai' && (aiGame.playerCards.length === 0 || aiGame.aiCards.length === 0))) { document.getElementById('gameOverModal').classList.remove('hidden'); } else if (document.getElementById('gameContainer').classList.contains('hidden')) { document.getElementById('setupModal').classList.remove('hidden'); } else { document.getElementById('setupModal').classList.remove('hidden'); }
    };
    window.resetGame = async function() { /* ... resetGame unchanged ... */
        console.log("Resetting game..."); if (unsubscribeGame) { unsubscribeGame(); unsubscribeGame = null; console.log("Unsubscribed from game changes."); } if (gameMode === 'multiplayer' && gameId && localGameState?.playerIds?.[0] === localPlayerId) { try { console.log(`Attempting to delete game ${gameId}...`); await deleteDoc(doc(db, "games", gameId)); console.log(`Game ${gameId} deleted.`); } catch (error) { console.error(`Error deleting game ${gameId}:`, error); } } else if (gameMode === 'multiplayer') { console.log("Not the host or no game ID, skipping game deletion."); } aiGame = { playerName: '', playerCards: [], aiCards: [], currentPlayerCard: null, currentAiCard: null, roundInProgress: false, turn: 'player' }; gameMode = null; gameId = null; localGameState = {}; hasCopiedShareLink = false; roundSoundPlayed = false; document.getElementById('gameOverModal').classList.add('hidden'); document.getElementById('leaderboardModal').classList.add('hidden'); document.getElementById('reflectionModal').classList.add('hidden'); document.getElementById('gameContainer').classList.add('hidden'); document.getElementById('multiplayerLobbyModal').classList.add('hidden'); document.getElementById('nameModal').classList.add('hidden'); document.getElementById('infoModal').classList.add('hidden'); document.getElementById('playerName').value = ''; document.getElementById('reflectionAnswer').value = ''; document.getElementById('shareLink').value = ''; 
        
        // NEU: QR-Code beim Reset leeren
        const qrContainer = document.getElementById('qrCodeContainer');
        if (qrContainer) qrContainer.innerHTML = '';
        
        document.getElementById('lobbyStatus').textContent = ''; document.getElementById('playerCard').innerHTML = ''; document.getElementById('aiCard').innerHTML = ''; updateStatusBar(0, 0); document.getElementById('setupModal').classList.remove('hidden'); window.history.pushState({}, document.title, window.location.pathname); console.log("Game reset complete.");
    };
    window.showWoodInfo = function(woodName) { /* ... showWoodInfo unchanged ... */
        const modal = document.getElementById('infoModal'); const titleEl = document.getElementById('infoModalTitle'); const contentEl = document.getElementById('infoModalContent'); titleEl.textContent = `Wissenswertes √ºber ${woodName}`; const infoDataKey = Object.keys(woodInfo).find(key => key.toLowerCase() === woodName.toLowerCase()); const infoData = infoDataKey ? woodInfo[infoDataKey] : null; if (infoData) { contentEl.innerHTML = `<p class="text-left text-sm sm:text-base">${infoData.info || 'Keine Beschreibung verf√ºgbar.'}</p><div class="grid grid-cols-1 sm:grid-cols-2 gap-4 mt-4"><div><h4 class="font-semibold mb-2 text-center text-sm sm:text-base">Baum</h4><img src="${infoData.bildBaum || ''}" alt="Bild von ${woodName} Baum" class="w-full max-h-48 sm:max-h-60 h-auto rounded-lg object-contain mx-auto border" onerror="this.parentElement.style.display='none';"></div><div><h4 class="font-semibold mb-2 text-center text-sm sm:text-base">Querschnitt</h4><img src="${infoData.bildQuerschnitt || ''}" alt="Bild von ${woodName} Querschnitt" class="w-full max-h-48 sm:max-h-60 h-auto rounded-lg object-contain mx-auto border" onerror="this.parentElement.style.display='none';"></div></div>`; } else { contentEl.innerHTML = "<p>F√ºr diese Holzart sind aktuell keine Detailinformationen verf√ºgbar.</p>"; } modal.classList.remove('hidden');
    };
    window.closeInfoModal = function() { /* ... closeInfoModal unchanged ... */
         document.getElementById('infoModal').classList.add('hidden');
    };

    // ===== Ton-Schalter Initialisierung und Event Listener =====
    const soundToggleButton = document.getElementById('soundToggle');

    // Initialen Status aus localStorage laden (oder default: nicht stumm)
    const savedMuteStatus = localStorage.getItem('holzquartett_isMuted');
    isMuted = savedMuteStatus === 'true'; // Setze globale Variable
    
    if(soundToggleButton) { // Sicherstellen, dass das Element existiert
        soundToggleButton.checked = !isMuted; // Setze Schalter-Zustand

        // Event Listener f√ºr den Schalter
        soundToggleButton.addEventListener('change', (event) => {
            isMuted = !event.target.checked; // Wenn checked, ist NICHT stumm
            localStorage.setItem('holzquartett_isMuted', isMuted); // Status speichern
            console.log("Ton ist", isMuted ? "AUS" : "AN");

            // Optional: Test-Sound abspielen, wenn Ton eingeschaltet wird
            if (!isMuted) {
                // Spiele einen kurzen Sound zur Best√§tigung, z.B. chime
                playSound(sounds.chime);
            }
        });
    }

</script>
